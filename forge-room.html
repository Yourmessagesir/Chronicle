<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="screen-orientation" content="any">
<meta name="theme-color" content="#f0ede6">
<link rel="manifest" href="data:application/json;charset=utf-8,%7B%22name%22%3A%22Forge%20Room%22%2C%22short_name%22%3A%22Forge%20Room%22%2C%22start_url%22%3A%22forge-room.html%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%23f0ede6%22%2C%22theme_color%22%3A%22%23c9a84c%22%2C%22icons%22%3A%5B%7B%22src%22%3A%22data%3Aimage%2Fsvg%2Bxml%2C%253Csvg%2520xmlns%3D%2527http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%2527%2520viewBox%3D%25270%25200%252064%252064%2527%253E%253Crect%2520width%3D%252764%2527%2520height%3D%252764%2527%2520fill%3D%2527%2523c9a84c%2527%2F%253E%253Ctext%2520x%3D%252732%2527%2520y%3D%252746%2527%2520font-size%3D%252740%2527%2520text-anchor%3D%2527middle%2527%2520fill%3D%2527white%2527%253E%25E2%259C%25A6%253C%2F%2520text%253E%253C%2F%2520svg%253E%22%2C%22sizes%22%3A%22192x192%22%2C%22type%22%3A%22image%2Fsvg%2Bxml%22%7D%5D%7D">
<title>Forge Room</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Pro:ital,wght@0,300;0,400;0,600;1,300&display=swap" rel="stylesheet">
<style>
*{box-sizing:border-box;margin:0;padding:0;-webkit-tap-highlight-color:transparent;}
:root{
  --gold:#c9a84c;--gold2:#e8c96a;--gold3:#f5e0a0;
  --bg:#0d0f14;--bg2:#141720;--bg3:#1c2030;
  --border:#2a2f45;--text:#d4cfc0;--text2:#8a8878;
  --red:#cc4444;--green:#44aa66;
}
html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none;}

/* â”€â”€ CANVAS â”€â”€ */
#c{display:block;width:100%;height:100%;}

/* â”€â”€ HUD OVERLAY â”€â”€ */
#hud{position:fixed;inset:0;pointer-events:none;z-index:10;}

/* Crosshair */
#crosshair{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
  width:20px;height:20px;pointer-events:none;opacity:0.7;}
#crosshair::before,#crosshair::after{content:'';position:absolute;background:rgba(201,168,76,0.8);}
#crosshair::before{width:2px;height:12px;top:4px;left:9px;}
#crosshair::after{width:12px;height:2px;top:9px;left:4px;}

/* Interaction hint */
#hint{position:absolute;bottom:38%;left:50%;transform:translateX(-50%);
  font-family:'Cinzel',serif;font-size:11px;letter-spacing:.12em;color:#7a5010;
  background:rgba(255,252,240,0.93);border:1px solid rgba(180,155,90,0.5);
  padding:6px 14px;border-radius:4px;opacity:0;transition:opacity .3s;pointer-events:none;
  white-space:nowrap;}
#hint.show{opacity:1;}

/* Top bar */
#topbar{position:absolute;top:0;left:0;right:0;height:44px;
  background:linear-gradient(to bottom,rgba(240,237,230,0.96),rgba(240,237,230,0));
  display:flex;align-items:center;padding:0 16px;gap:12px;pointer-events:auto;}
#topbar h1{font-family:'Cinzel',serif;font-size:13px;color:#7a5c1e;letter-spacing:.15em;}
#topbar .sub{font-size:10px;color:#a08040;letter-spacing:.08em;}
.hbtn{background:rgba(255,252,245,0.92);border:1px solid rgba(180,155,90,0.5);color:#5a4010;
  padding:5px 12px;border-radius:4px;font-family:'Cinzel',serif;font-size:9px;
  letter-spacing:.08em;cursor:pointer;pointer-events:auto;}
.hbtn:active,.hbtn:hover{border-color:var(--gold);color:#7a5010;background:#fff8e8;}
#topbar .spacer{flex:1;}

/* Compass / room label */
#roomlabel{position:absolute;top:52px;left:50%;transform:translateX(-50%);
  font-family:'Cinzel',serif;font-size:9px;letter-spacing:.18em;color:#a08040;
  pointer-events:none;opacity:0;transition:opacity .5s;}
#roomlabel.show{opacity:1;}

/* â”€â”€ VIRTUAL JOYSTICK â”€â”€ */
#vjLeft,#vjRight{position:fixed;bottom:28px;width:120px;height:120px;
  border-radius:50%;background:rgba(201,168,76,0.06);
  border:1.5px solid rgba(201,168,76,0.2);pointer-events:auto;z-index:20;
  display:flex;align-items:center;justify-content:center;}
#vjLeft{left:28px;}
#vjRight{right:28px;}
.vj-knob{width:44px;height:44px;border-radius:50%;
  background:rgba(201,168,76,0.25);border:1.5px solid rgba(201,168,76,0.5);
  pointer-events:none;transition:transform .05s;}
#vjLabel{position:fixed;bottom:12px;left:50%;transform:translateX(-50%);
  font-family:'Cinzel',serif;font-size:8px;letter-spacing:.1em;color:rgba(201,168,76,0.35);
  pointer-events:none;z-index:20;}

/* â”€â”€ BOTTOM ACTION BUTTONS â”€â”€ */
#actionBar{position:fixed;bottom:28px;left:50%;transform:translateX(-50%);
  display:flex;gap:12px;z-index:20;pointer-events:auto;}
.abtn{width:48px;height:48px;border-radius:50%;
  background:rgba(13,15,20,0.85);border:1.5px solid var(--border);
  color:var(--text2);font-size:18px;cursor:pointer;
  display:flex;align-items:center;justify-content:center;
  font-family:'Cinzel',serif;transition:all .2s;}
.abtn:active,.abtn.active{border-color:var(--gold);color:var(--gold2);
  background:rgba(201,168,76,0.12);}
.abtn-label{font-size:7px;letter-spacing:.05em;display:block;margin-top:2px;color:inherit;}

/* â”€â”€ MODAL OVERLAY â”€â”€ */
#modal{position:fixed;inset:0;z-index:100;display:none;
  background:rgba(0,0,0,0.85);backdrop-filter:blur(4px);
  align-items:center;justify-content:center;padding:16px;}
#modal.open{display:flex;}
#modalInner{background:var(--bg2);border:1px solid var(--border);border-radius:6px;
  width:100%;max-width:480px;max-height:90vh;overflow-y:auto;position:relative;
  animation:slideUp .25s ease;}
@keyframes slideUp{from{transform:translateY(20px);opacity:0;}to{transform:translateY(0);opacity:1;}}
#modalClose{position:sticky;top:0;float:right;margin:10px 10px 0 0;
  background:var(--bg3);border:1px solid var(--border);color:var(--text2);
  width:32px;height:32px;border-radius:4px;cursor:pointer;font-size:16px;
  display:flex;align-items:center;justify-content:center;z-index:1;}
#modalClose:hover{color:var(--gold);}
#modalBody{padding:16px;clear:both;}

/* â”€â”€ CARD DETAIL â”€â”€ */
.card-detail-frame{border:2px solid var(--gold);border-radius:8px;overflow:hidden;
  background:var(--bg3);margin-bottom:14px;}
.card-detail-header{background:linear-gradient(135deg,var(--bg2),var(--bg3));
  padding:14px 16px;display:flex;justify-content:space-between;align-items:flex-start;}
.card-detail-name{font-family:'Cinzel',serif;font-size:18px;color:var(--gold2);}
.card-detail-cost{font-family:'Cinzel',serif;font-size:22px;color:var(--gold);
  background:rgba(201,168,76,0.15);border:1.5px solid var(--gold);
  width:38px;height:38px;border-radius:50%;display:flex;align-items:center;justify-content:center;}
.card-detail-type{font-size:11px;color:var(--text2);letter-spacing:.1em;margin-top:3px;}
.card-detail-body{padding:12px 16px;}
.card-stat-row{display:flex;gap:12px;margin-bottom:10px;}
.card-stat{background:var(--bg2);border:1px solid var(--border);border-radius:4px;
  padding:6px 12px;flex:1;text-align:center;}
.card-stat .sv{font-family:'Cinzel',serif;font-size:18px;color:var(--text);}
.card-stat .sl{font-size:9px;color:var(--text2);letter-spacing:.1em;}
.card-kw-list{display:flex;flex-wrap:wrap;gap:5px;margin-bottom:10px;}
.card-kw{background:rgba(201,168,76,0.1);border:1px solid rgba(201,168,76,0.3);
  border-radius:3px;padding:2px 8px;font-size:10px;color:var(--gold2);letter-spacing:.05em;}
.card-desc{font-size:13px;color:var(--text2);line-height:1.6;font-style:italic;}

/* â”€â”€ SETTINGS PANEL â”€â”€ */
.settings-row{display:flex;align-items:center;justify-content:space-between;
  padding:10px 0;border-bottom:1px solid var(--border);}
.settings-row:last-child{border-bottom:none;}
.settings-label{font-family:'Cinzel',serif;font-size:10px;letter-spacing:.1em;color:var(--text);}
.settings-sub{font-size:10px;color:var(--text2);}
.settings-row input[type=range]{width:120px;accent-color:var(--gold);}
.settings-row select{background:var(--bg3);border:1px solid var(--border2);
  color:var(--text);padding:4px 8px;border-radius:4px;font-size:11px;}
.toggle-sw{width:40px;height:22px;border-radius:11px;background:var(--bg3);
  border:1px solid var(--border);position:relative;cursor:pointer;transition:background .2s;}
.toggle-sw.on{background:rgba(201,168,76,0.3);border-color:var(--gold);}
.toggle-sw::after{content:'';width:16px;height:16px;border-radius:50%;
  background:var(--text2);position:absolute;top:2px;left:2px;transition:all .2s;}
.toggle-sw.on::after{left:20px;background:var(--gold);}

/* â”€â”€ LOADING SCREEN â”€â”€ */
#loading{position:fixed;inset:0;background:#f0ede6;z-index:1000;
  display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;}
#loading h1{font-family:'Cinzel',serif;font-size:24px;color:#7a5010;letter-spacing:.2em;}
#loading p{font-size:12px;color:#a08040;letter-spacing:.1em;}
.load-bar-outer{width:200px;height:3px;background:#ddd8cc;border-radius:2px;overflow:hidden;}
.load-bar-inner{height:100%;background:var(--gold);width:0%;transition:width .3s;border-radius:2px;}

/* â”€â”€ CHRONICLE IFRAME OVERLAY â”€â”€ */
#chronicleOverlay{position:fixed;inset:0;z-index:80;display:none;flex-direction:column;
  background:#0d0f14;}
#chronicleOverlay.open{display:flex;}

#chronicleHeader{display:flex;align-items:center;gap:10px;padding:0 14px;
  background:#0d0f14;border-bottom:1px solid var(--border);
  height:48px;flex-shrink:0;}
#chronicleHeader h2{font-family:'Cinzel',serif;font-size:12px;color:var(--gold2);
  letter-spacing:.15em;flex:1;}
#chronicleTabBar{display:flex;gap:6px;overflow-x:auto;}
#chronicleTabBar::-webkit-scrollbar{display:none;}
.chr-tab-btn{background:transparent;border:1px solid transparent;
  color:var(--text2);padding:5px 10px;border-radius:4px;
  font-family:'Cinzel',serif;font-size:8px;letter-spacing:.08em;
  cursor:pointer;white-space:nowrap;transition:all .15s;}
.chr-tab-btn:hover{color:var(--text);border-color:var(--border);}
.chr-tab-btn.active{color:var(--gold2);border-color:var(--gold);
  background:rgba(201,168,76,0.08);}
#chronicleClose{background:transparent;border:1px solid var(--border);
  color:var(--text2);width:32px;height:32px;border-radius:4px;
  cursor:pointer;font-size:16px;display:flex;align-items:center;
  justify-content:center;flex-shrink:0;}
#chronicleClose:hover{color:var(--gold);border-color:var(--gold);}

#chronicleFrame{flex:1;border:none;display:block;width:100%;background:#0d0f14;}

#chronicleLoading{position:absolute;inset:48px 0 0 0;display:flex;
  flex-direction:column;align-items:center;justify-content:center;
  gap:12px;background:#0d0f14;z-index:1;pointer-events:none;
  transition:opacity .4s;}
#chronicleLoading.hidden{opacity:0;}
#chronicleLoading p{font-family:'Cinzel',serif;font-size:11px;color:var(--text2);
  letter-spacing:.1em;}

/* â”€â”€ INSTALL BANNER â”€â”€ */
#installBanner{position:fixed;bottom:0;left:0;right:0;z-index:300;
  background:rgba(250,248,240,0.97);border-top:1px solid rgba(180,155,90,0.5);
  display:none;align-items:center;gap:12px;padding:10px 16px;
  font-family:'Cinzel',serif;}
#installBanner.show{display:flex;}
#installBanner p{flex:1;font-size:10px;color:#5a4010;letter-spacing:.08em;}
#installBanner button{background:var(--gold);border:none;color:#2a1800;
  padding:8px 16px;border-radius:4px;font-family:'Cinzel',serif;font-size:9px;
  letter-spacing:.08em;cursor:pointer;font-weight:700;}
#installBanner .dismiss{background:transparent;border:1px solid rgba(180,155,90,0.4);
  color:#8a6820;padding:6px 10px;}

/* â”€â”€ TOAST â”€â”€ */
#toast{position:fixed;bottom:180px;left:50%;transform:translateX(-50%);
  background:rgba(13,15,20,0.95);border:1px solid var(--border);
  color:var(--text);font-family:'Cinzel',serif;font-size:10px;letter-spacing:.1em;
  padding:8px 16px;border-radius:4px;z-index:200;opacity:0;
  transition:opacity .3s;pointer-events:none;white-space:nowrap;}
#toast.show{opacity:1;}
#toast.good{border-color:var(--green);color:var(--green);}
#toast.bad{border-color:var(--red);color:var(--red);}

/* â”€â”€ PLAYTEST IFRAME OVERLAY â”€â”€ */
#playtestOverlay{position:fixed;inset:0;z-index:80;display:none;flex-direction:column;
  background:#0d0f14;}
#playtestOverlay.open{display:flex;}
#playtestHeader{display:flex;align-items:center;gap:10px;padding:0 14px;
  background:#0d0f14;border-bottom:1px solid var(--border);
  height:48px;flex-shrink:0;}
#playtestHeader h2{font-family:'Cinzel',serif;font-size:12px;color:var(--gold2);
  letter-spacing:.15em;flex:1;}
#playtestHeader .pt-btn{background:transparent;border:1px solid var(--border);
  color:var(--text2);padding:5px 12px;border-radius:4px;
  font-family:'Cinzel',serif;font-size:8px;letter-spacing:.08em;
  cursor:pointer;white-space:nowrap;transition:all .15s;}
#playtestHeader .pt-btn:hover{color:var(--gold);border-color:var(--gold);}
#playtestFrame{flex:1;border:none;display:block;width:100%;background:#0d0f14;}
#playtestLoading{position:absolute;inset:48px 0 0 0;display:flex;
  flex-direction:column;align-items:center;justify-content:center;
  gap:12px;background:#0d0f14;z-index:1;pointer-events:none;transition:opacity .4s;}
#playtestLoading.hidden{opacity:0;pointer-events:none;}
#playtestLoading p{font-family:'Cinzel',serif;font-size:11px;color:var(--text2);
  letter-spacing:.1em;}

/* â”€â”€ DICE RESULT â”€â”€ */
#diceResult{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
  z-index:150;pointer-events:none;opacity:0;transition:opacity .2s;
  font-family:'Cinzel',serif;text-align:center;}
#diceResult .dice-num{font-size:72px;color:var(--gold2);
  text-shadow:0 0 30px rgba(201,168,76,0.8), 0 0 60px rgba(201,168,76,0.4);
  line-height:1;display:block;}
#diceResult .dice-label{font-size:11px;color:var(--text2);letter-spacing:.15em;
  margin-top:4px;display:block;}
#diceResult.show{opacity:1;}

/* â”€â”€ MINIMAP (future) â”€â”€ */
#minimap{position:fixed;top:52px;right:12px;width:70px;height:70px;
  border:1px solid var(--border);border-radius:4px;
  background:rgba(13,15,20,0.7);display:none;pointer-events:none;}

/* Scrollable card wall UI */
#wallNav{position:fixed;bottom:170px;left:50%;transform:translateX(-50%);
  display:flex;gap:8px;z-index:20;pointer-events:auto;opacity:0;
  transition:opacity .3s;}
#wallNav.show{opacity:1;}
.wallnav-btn{background:rgba(13,15,20,0.85);border:1px solid var(--border);
  color:var(--text2);padding:6px 14px;border-radius:4px;
  font-family:'Cinzel',serif;font-size:9px;letter-spacing:.08em;cursor:pointer;}
.wallnav-btn:hover{border-color:var(--gold);color:var(--gold);}

/* â”€â”€ WHITEBOARD OVERLAY â”€â”€ */
#wbOverlay{position:fixed;inset:0;z-index:50;display:none;flex-direction:column;
  background:rgba(8,10,16,0.98);}
#wbOverlay.open{display:flex;}

#wbHeader{display:flex;align-items:center;gap:10px;padding:8px 14px;
  background:rgba(13,15,20,0.95);border-bottom:1px solid var(--border);
  flex-shrink:0;min-height:48px;}
#wbHeader h2{font-family:'Cinzel',serif;font-size:11px;color:var(--gold2);
  letter-spacing:.15em;flex:1;}
#wbWallLabel{font-size:9px;color:var(--text2);letter-spacing:.1em;font-family:'Cinzel',serif;}

/* Scrollable canvas viewport */
#wbViewport{flex:1;overflow:hidden;position:relative;touch-action:none;
  background:#0e1018;}

#wbCanvas{display:block;position:absolute;top:0;left:0;cursor:crosshair;touch-action:none;}
#wbCanvas.erasing{cursor:cell;}
#wbCanvas.panning{cursor:grab;}
#wbCanvas.panning:active{cursor:grabbing;}

/* Zoom controls */
#wbZoomBar{position:absolute;top:8px;right:8px;z-index:5;
  display:flex;flex-direction:column;gap:4px;}
.wb-zoom-btn{width:34px;height:34px;border-radius:4px;
  background:rgba(13,15,20,0.9);border:1px solid var(--border);
  color:var(--text);font-size:18px;cursor:pointer;
  display:flex;align-items:center;justify-content:center;
  font-family:'Cinzel',serif;}
.wb-zoom-btn:active{border-color:var(--gold);color:var(--gold);}
#wbZoomLabel{font-family:'Cinzel',serif;font-size:8px;color:var(--text2);
  text-align:center;letter-spacing:.06em;}

/* Pan mode toggle */
#wbPanBtn{padding:5px 10px;border-radius:4px;background:rgba(255,255,255,0.05);
  border:1px solid var(--border);color:var(--text2);cursor:pointer;
  font-family:'Cinzel',serif;font-size:8px;letter-spacing:.06em;
  white-space:nowrap;flex-shrink:0;transition:all .15s;}
#wbPanBtn.active{border-color:var(--gold);color:var(--gold);background:rgba(201,168,76,0.12);}

#wbToolbar{display:flex;align-items:center;gap:6px;padding:8px 12px;
  background:rgba(13,15,20,0.95);border-top:1px solid var(--border);
  flex-shrink:0;overflow-x:auto;flex-wrap:nowrap;}
#wbToolbar::-webkit-scrollbar{display:none;}

.wb-section{display:flex;align-items:center;gap:4px;padding-right:8px;
  border-right:1px solid var(--border);margin-right:2px;}
.wb-section:last-child{border-right:none;}
.wb-section-label{font-family:'Cinzel',serif;font-size:7px;color:var(--text2);
  letter-spacing:.1em;margin-right:3px;white-space:nowrap;}

/* Color swatches */
.wb-color{width:26px;height:26px;border-radius:50%;border:2px solid transparent;
  cursor:pointer;transition:all .15s;flex-shrink:0;}
.wb-color.active{border-color:var(--gold2);transform:scale(1.2);
  box-shadow:0 0 8px rgba(201,168,76,0.5);}

/* Size buttons */
.wb-size{width:30px;height:30px;border-radius:4px;background:rgba(255,255,255,0.07);
  border:1px solid var(--border);cursor:pointer;display:flex;align-items:center;
  justify-content:center;flex-shrink:0;transition:all .15s;}
.wb-size.active{border-color:var(--gold);background:rgba(201,168,76,0.15);}
.wb-size-dot{border-radius:50%;background:var(--text);pointer-events:none;}

/* Tool buttons */
.wb-btn{padding:5px 10px;border-radius:4px;background:rgba(255,255,255,0.05);
  border:1px solid var(--border);color:var(--text2);cursor:pointer;
  font-family:'Cinzel',serif;font-size:8px;letter-spacing:.06em;
  white-space:nowrap;flex-shrink:0;transition:all .15s;}
.wb-btn:hover,.wb-btn:active{border-color:var(--gold);color:var(--gold);}
.wb-btn.active{border-color:var(--red);color:var(--red);background:rgba(204,68,68,0.1);}
.wb-btn.danger{border-color:rgba(204,68,68,0.3);}
.wb-btn.danger:hover{border-color:var(--red);color:var(--red);}
.wb-btn.save-btn{border-color:rgba(68,170,102,0.4);color:var(--green);}
.wb-btn.save-btn:hover{border-color:var(--green);background:rgba(68,170,102,0.1);}

/* Undo count badge */
#wbUndoCount{font-size:7px;color:var(--text2);font-family:'Cinzel',serif;
  min-width:14px;text-align:center;}

/* Pen cursor indicator */
#wbCursor{position:fixed;pointer-events:none;border-radius:50%;
  border:1.5px solid rgba(201,168,76,0.7);z-index:60;display:none;
  transform:translate(-50%,-50%);}
</style>
</head>
<body>

<!-- Loading -->
<div id="loading">
  <div style="font-size:32px;margin-bottom:4px;">âœ¦</div>
  <h1>FORGE ROOM</h1>
  <p>PREPARING THE WORKSHOP...</p>
  <div class="load-bar-outer"><div class="load-bar-inner" id="loadBar"></div></div>
  <p id="loadMsg" style="font-size:10px;margin-top:4px;color:var(--text2);">Loading engine...</p>
</div>

<!-- 3D Canvas -->
<canvas id="c"></canvas>

<!-- HUD -->
<div id="hud">
  <div id="crosshair"></div>
  <div id="hint"></div>
  <div id="roomlabel"></div>

  <div id="topbar">
    <span style="font-size:20px;color:var(--gold);">âœ¦</span>
    <h1>FORGE ROOM</h1>
    <span class="sub" id="topSub">WORKSHOP</span>
    <div class="spacer"></div>
    <button class="hbtn" onclick="openSettings()">âš™</button>
    <button class="hbtn" onclick="window.location.href='forge.html'">FORGE</button>
    <button class="hbtn" onclick="window.location.href='lifeapp.html'">CHRONICLE</button>
  </div>
</div>

<!-- Virtual Joysticks -->
<div id="vjLeft"><div class="vj-knob" id="vjLKnob"></div></div>
<div id="vjRight"><div class="vj-knob" id="vjRKnob"></div></div>
<div id="vjLabel">MOVE &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOOK</div>

<!-- Action Buttons -->
<div id="actionBar">
  <button class="abtn" id="btnDraw" onclick="toggleDrawMode()" title="Whiteboard">
    âœ<span class="abtn-label">DRAW</span>
  </button>
</div>

<!-- Wall navigation -->
<div id="wallNav">
  <button class="wallnav-btn" onclick="galleryScroll(-1)">â—€ PREV</button>
  <span id="wallNavLabel" style="font-family:'Cinzel',serif;font-size:9px;color:var(--text2);display:flex;align-items:center;letter-spacing:.08em;">CARD GALLERY</span>
  <button class="wallnav-btn" onclick="galleryScroll(1)">NEXT â–¶</button>
</div>

<!-- Whiteboard Overlay -->
<div id="wbOverlay">
  <div id="wbHeader">
    <span style="font-size:16px;">âœ</span>
    <h2>WHITEBOARD</h2>
    <span id="wbWallLabel">EAST WALL</span>
    <div style="flex:1"></div>
    <span id="wbSaveStatus" style="font-family:'Cinzel',serif;font-size:8px;color:var(--text2);letter-spacing:.08em;margin-right:8px;"></span>
    <button class="wb-btn" onclick="wbClose()" style="font-size:10px;padding:6px 14px;">âœ• CLOSE</button>
  </div>
  <div id="wbViewport">
    <canvas id="wbCanvas"></canvas>
    <div id="wbZoomBar">
      <button class="wb-zoom-btn" onclick="wbZoom(1.25)" title="Zoom In">+</button>
      <div id="wbZoomLabel">100%</div>
      <button class="wb-zoom-btn" onclick="wbZoom(0.8)" title="Zoom Out">âˆ’</button>
      <button class="wb-zoom-btn" onclick="wbResetView()" title="Reset View" style="font-size:11px;">âŒ‚</button>
    </div>
  </div>
  <div id="wbCursor"></div>
  <div id="wbToolbar">
    <div class="wb-section">
      <span class="wb-section-label">COLOR</span>
      <div class="wb-color active" data-color="#d4cfc0" style="background:#d4cfc0;" onclick="wbSetColor(this)"></div>
      <div class="wb-color" data-color="#080c14" style="background:#080c14;border:2px solid rgba(255,255,255,0.25);" onclick="wbSetColor(this)"></div>
      <div class="wb-color" data-color="#c9a84c" style="background:#c9a84c;" onclick="wbSetColor(this)"></div>
      <div class="wb-color" data-color="#cc4444" style="background:#cc4444;" onclick="wbSetColor(this)"></div>
      <div class="wb-color" data-color="#4488cc" style="background:#4488cc;" onclick="wbSetColor(this)"></div>
      <div class="wb-color" data-color="#44aa66" style="background:#44aa66;" onclick="wbSetColor(this)"></div>
      <div class="wb-color" data-color="#aa44cc" style="background:#aa44cc;" onclick="wbSetColor(this)"></div>
    </div>
    <div class="wb-section">
      <span class="wb-section-label">SIZE</span>
      <div class="wb-size" data-size="2" onclick="wbSetSize(this)"><div class="wb-size-dot" style="width:3px;height:3px;"></div></div>
      <div class="wb-size active" data-size="5" onclick="wbSetSize(this)"><div class="wb-size-dot" style="width:6px;height:6px;"></div></div>
      <div class="wb-size" data-size="12" onclick="wbSetSize(this)"><div class="wb-size-dot" style="width:12px;height:12px;"></div></div>
      <div class="wb-size" data-size="24" onclick="wbSetSize(this)"><div class="wb-size-dot" style="width:18px;height:18px;"></div></div>
      <div class="wb-size" data-size="48" onclick="wbSetSize(this)"><div class="wb-size-dot" style="width:22px;height:22px;"></div></div>
    </div>
    <div class="wb-section">
      <span class="wb-section-label">TOOL</span>
      <button class="wb-btn" id="wbEraserBtn" onclick="wbToggleEraser()">âŒ« ERASE</button>
      <button class="wb-btn" id="wbPanBtn" onclick="wbTogglePan()">âœ‹ PAN</button>
      <button class="wb-btn" onclick="wbUndo()">â†© UNDO</button>
      <span id="wbUndoCount" style="font-size:9px;color:var(--text2);font-family:'Cinzel',serif;min-width:16px;text-align:center;">0</span>
    </div>
    <div class="wb-section">
      <span class="wb-section-label">FILE</span>
      <button class="wb-btn save-btn" onclick="wbSave()">ğŸ’¾ SAVE</button>
      <button class="wb-btn" onclick="wbExportPNG()">â†“ PNG</button>
      <button class="wb-btn danger" onclick="wbClear()">ğŸ—‘ CLEAR</button>
    </div>
    <div class="wb-section">
      <span class="wb-section-label">WALL</span>
      <button class="wb-btn" id="wbWallBtn" onclick="wbSwitchWall()">â†” SWITCH</button>
    </div>
  </div>
</div>

<!-- Chronicle Iframe Overlay -->
<div id="chronicleOverlay">
  <div id="chronicleHeader">
    <span style="font-size:18px;color:var(--gold);">âœ¦</span>
    <h2>THE CHRONICLE</h2>
    <div id="chronicleTabBar">
      <button class="chr-tab-btn active" data-sec="book"        onclick="chrSwitchTab(this,'book')">ğŸ“– BOOK</button>
      <button class="chr-tab-btn"        data-sec="comic"       onclick="chrSwitchTab(this,'comic')">ğŸ¨ COMIC</button>
      <button class="chr-tab-btn"        data-sec="rpg"         onclick="chrSwitchTab(this,'rpg')">âš” RPG</button>
      <button class="chr-tab-btn"        data-sec="board"       onclick="chrSwitchTab(this,'board')">ğŸ“‹ BOARD</button>
    </div>
    <button id="chronicleClose" onclick="chrClose()">âœ•</button>
  </div>
  <div style="position:relative;flex:1;display:flex;flex-direction:column;">
    <div id="chronicleLoading">
      <div style="font-size:28px;">âœ¦</div>
      <p>OPENING CHRONICLE...</p>
    </div>
    <iframe id="chronicleFrame" src="" allow="fullscreen"></iframe>
  </div>
</div>

<!-- Playtest Iframe Overlay -->
<div id="playtestOverlay">
  <div id="playtestHeader">
    <span style="font-size:18px;color:var(--gold);">âš”</span>
    <h2>PLAYTEST TABLE</h2>
    <button class="pt-btn" onclick="window.open('playtest.html','_blank')">â†— NEW TAB</button>
    <button class="pt-btn" id="playtestClose" onclick="closePlatyest()" style="margin-left:4px;">âœ• CLOSE</button>
  </div>
  <div style="position:relative;flex:1;display:flex;flex-direction:column;">
    <div id="playtestLoading">
      <div style="font-size:28px;">âš”</div>
      <p>LOADING PLAYTEST...</p>
    </div>
    <iframe id="playtestFrame" src="" allow="fullscreen"></iframe>
  </div>
</div>

<!-- Dice Result Display -->
<div id="diceResult">
  <span class="dice-num" id="diceNum">6</span>
  <span class="dice-label" id="diceLabel">D6</span>
</div>

<!-- Modal -->
<div id="modal">
  <div id="modalInner">
    <button id="modalClose" onclick="closeModal()">âœ•</button>
    <div id="modalBody"></div>
  </div>
</div>

<!-- Install Banner -->
<div id="installBanner">
  <span style="font-size:20px;">âœ¦</span>
  <p>ADD FORGE ROOM TO HOME SCREEN</p>
  <button onclick="doInstall()">INSTALL</button>
  <button class="dismiss" onclick="document.getElementById('installBanner').classList.remove('show')">âœ•</button>
</div>

<!-- Toast -->
<div id="toast"></div>

<!-- Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONSTANTS & CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const STORE_FORGE = 'cardforge_v3';
const STORE_ROOM_SETTINGS = 'forge_room_settings';
const STORE_CAMERA = 'forge_room_camera_pos';
const STORE_WB = key => `forge_room_whiteboard_${key}`;

const ROOM_W = 20, ROOM_H = 6, ROOM_D = 24;
const WALL_N = -ROOM_D/2 + 0.3;
const WALL_S =  ROOM_D/2 - 0.3;
const WALL_E =  ROOM_W/2 - 0.3;
const WALL_W = -ROOM_W/2 + 0.3;

let settings = {
  fov: 75,
  sensitivity: 2.5,
  speed: 4.0,
  invertY: false,
  deadzone: 0.15,
  sprintMult: 2.5,
  showJoystick: true,
  perfMode: false,
  ambientSound: false,
  cardSort: 'name',
  lighting: 'torch',
  cardsPerPage: 5,
  cardRows: 1,
};

function loadSettings(){
  try{const s=localStorage.getItem(STORE_ROOM_SETTINGS);if(s)settings=Object.assign(settings,JSON.parse(s));}catch(e){}
}
function saveSettings(){
  localStorage.setItem(STORE_ROOM_SETTINGS, JSON.stringify(settings));
}
loadSettings();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FORGE DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let forgeData = {cards:[],decks:[],fusions:[],games:[],nextId:1};
function loadForgeData(){
  try{const s=localStorage.getItem(STORE_FORGE);if(s)forgeData=JSON.parse(s);}catch(e){}
}
loadForgeData();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  THREE.JS SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:!settings.perfMode, alpha:false});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, settings.perfMode?1:2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = !settings.perfMode;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.8;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0ede6);
scene.fog = new THREE.Fog(0xf0ede6, 14, 30);

const camera = new THREE.PerspectiveCamera(settings.fov, window.innerWidth/window.innerHeight, 0.1, 50);
camera.position.set(0, 1.7, ROOM_D/2 - 2);

const clock = new THREE.Clock();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TEXTURES & MATERIALS (procedural)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const texLoader = new THREE.TextureLoader();

function makeStoneTexture(w=256,h=256,dark=true){
  const c2 = document.createElement('canvas');c2.width=w;c2.height=h;
  const ctx = c2.getContext('2d');
  // White plaster / gallery wall
  ctx.fillStyle = '#f5f2ec'; ctx.fillRect(0,0,w,h);
  // Very subtle plaster texture â€” tiny noise variation
  const id = ctx.getImageData(0,0,w,h);
  for(let i=0;i<id.data.length;i+=4){
    const n=(Math.random()-0.5)*8;
    id.data[i]   = Math.min(255,Math.max(220,id.data[i]+n));
    id.data[i+1] = Math.min(255,Math.max(218,id.data[i+1]+n));
    id.data[i+2] = Math.min(255,Math.max(210,id.data[i+2]+n));
  }
  ctx.putImageData(id,0,0);
  // Faint vertical seam lines (wall panels)
  ctx.strokeStyle='rgba(180,170,155,0.25)';ctx.lineWidth=1;
  for(let x=64;x<w;x+=64){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,h);ctx.stroke();}
  const t = new THREE.CanvasTexture(c2);
  t.wrapS=t.wrapT=THREE.RepeatWrapping;
  return t;
}

function makeFloorTexture(){
  const c2=document.createElement('canvas');c2.width=256;c2.height=256;
  const ctx=c2.getContext('2d');
  // Cream / warm ivory base
  ctx.fillStyle='#e8e0d0';ctx.fillRect(0,0,256,256);
  // Polished tile grid
  const pw=32;
  for(let row=0;row<256/pw;row++){
    for(let col=0;col<256/pw;col++){
      const shade=(Math.random()-0.5)*10;
      const r=Math.min(255,232+shade), g=Math.min(255,224+shade), b=Math.min(255,208+shade);
      ctx.fillStyle=`rgb(${r},${g},${b})`;
      ctx.fillRect(col*pw+1,row*pw+1,pw-2,pw-2);
      // Grout line
      ctx.strokeStyle='rgba(190,180,165,0.5)';ctx.lineWidth=1;
      ctx.strokeRect(col*pw,row*pw,pw,pw);
    }
  }
  // Subtle gloss highlight diagonal
  const grd=ctx.createLinearGradient(0,0,256,256);
  grd.addColorStop(0,'rgba(255,255,255,0.08)');
  grd.addColorStop(0.5,'rgba(255,255,255,0)');
  grd.addColorStop(1,'rgba(255,255,255,0.04)');
  ctx.fillStyle=grd;ctx.fillRect(0,0,256,256);
  const t=new THREE.CanvasTexture(c2);
  t.wrapS=t.wrapT=THREE.RepeatWrapping;
  t.repeat.set(4,6);
  return t;
}

function makeWoodTexture(){
  const c2=document.createElement('canvas');c2.width=256;c2.height=256;
  const ctx=c2.getContext('2d');
  // Lighter warm oak for gallery â€” matches cream aesthetic
  for(let y=0;y<256;y++){
    const shade=Math.sin(y*0.4+Math.random()*0.3)*12;
    ctx.fillStyle=`rgb(${165+shade},${120+shade},${75+shade})`;
    ctx.fillRect(0,y,256,1);
  }
  const t=new THREE.CanvasTexture(c2);
  t.wrapS=t.wrapT=THREE.RepeatWrapping;
  return t;
}

const stoneTex = makeStoneTexture();
stoneTex.repeat.set(4,2);
const floorTex = makeFloorTexture();
const woodTex = makeWoodTexture();

const matWall = new THREE.MeshLambertMaterial({map:stoneTex});
const matFloor = new THREE.MeshLambertMaterial({map:floorTex});
const matCeiling = new THREE.MeshLambertMaterial({color:0xfaf8f4});
const matWood = new THREE.MeshLambertMaterial({map:woodTex,color:0xb87840});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ROOM GEOMETRY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildRoom(){
  // Floor
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_W,ROOM_D), matFloor);
  floor.rotation.x=-Math.PI/2; floor.receiveShadow=true; scene.add(floor);

  // Ceiling
  const ceil = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_W,ROOM_D), matCeiling);
  ceil.rotation.x=Math.PI/2; ceil.position.y=ROOM_H; scene.add(ceil);

  // North wall (card gallery)
  const wallN = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_W,ROOM_H), matWall);
  wallN.position.set(0,ROOM_H/2,-ROOM_D/2); scene.add(wallN);

  // South wall (chronicle)
  const wallS = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_W,ROOM_H), matWall);
  wallS.rotation.y=Math.PI; wallS.position.set(0,ROOM_H/2,ROOM_D/2); scene.add(wallS);

  // East wall (whiteboard 1)
  const stE = makeStoneTexture(256,256,false);stE.repeat.set(3,2);
  const matWE = new THREE.MeshLambertMaterial({map:stE});
  const wallE = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_D,ROOM_H), matWE);
  wallE.rotation.y=-Math.PI/2; wallE.position.set(ROOM_W/2,ROOM_H/2,0); scene.add(wallE);

  // West wall (whiteboard 2)
  const stW = makeStoneTexture(256,256,false);stW.repeat.set(3,2);
  const matWW = new THREE.MeshLambertMaterial({map:stW});
  const wallW = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_D,ROOM_H), matWW);
  wallW.rotation.y=Math.PI/2; wallW.position.set(-ROOM_W/2,ROOM_H/2,0); scene.add(wallW);

  // Register materials for whiteboard texture updates
  wbRegisterMaterials(matWE, matWW);

  // Wooden beams on ceiling â€” shortened to not cover whiteboard walls
  for(let i=-8;i<=8;i+=4){
    const beam = new THREE.Mesh(new THREE.BoxGeometry(ROOM_W-2.0,0.2,0.3), matWood);
    beam.position.set(0,ROOM_H-0.1,i); scene.add(beam);
  }
  // Side pillars â€” only on N/S ends, not covering whiteboard walls
  [-ROOM_W/2+0.15, ROOM_W/2-0.15].forEach(x=>{
    [-10, -6, 10, 6].forEach(z=>{  // Only near N and S walls
      const pillar=new THREE.Mesh(new THREE.BoxGeometry(0.3,ROOM_H,0.3),matWood);
      pillar.position.set(x,ROOM_H/2,z); scene.add(pillar);
    });
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LIGHTING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const torchLights = [];
function buildLighting(){
  // Bright ambient â€” gallery feel
  const ambient = new THREE.AmbientLight(0xfff8f0, 1.2);
  scene.add(ambient);

  // Main overhead fill lights (gallery track lighting style)
  const overheadPositions = [
    [0, ROOM_H-0.3, -8], [0, ROOM_H-0.3, 0], [0, ROOM_H-0.3, 8],
    [-4, ROOM_H-0.3, -4], [4, ROOM_H-0.3, -4],
    [-4, ROOM_H-0.3, 4],  [4, ROOM_H-0.3, 4],
  ];
  overheadPositions.forEach(([x,y,z])=>{
    const light = new THREE.PointLight(0xfff5e8, 0.9, 12);
    light.position.set(x,y,z);
    light.castShadow = !settings.perfMode;
    scene.add(light);

    // Light fixture mesh (small cylinder)
    const fixture = new THREE.Mesh(
      new THREE.CylinderGeometry(0.08,0.06,0.15,8),
      new THREE.MeshLambertMaterial({color:0xcccccc})
    );
    fixture.position.set(x, ROOM_H-0.05, z);
    scene.add(fixture);
  });

  // Accent warm wall-wash lights (illuminate the card gallery wall)
  const wallWash = new THREE.DirectionalLight(0xfff0d8, 0.5);
  wallWash.position.set(0, ROOM_H, -ROOM_D/2 + 3);
  wallWash.target.position.set(0, ROOM_H/2, -ROOM_D/2);
  scene.add(wallWash); scene.add(wallWash.target);

  // Table accent
  const tableLight = new THREE.PointLight(0xfff8ee, 0.6, 7);
  tableLight.position.set(0, 3, 2);
  scene.add(tableLight);

  // Keep torchLights array populated (empty â€” no flicker needed in gallery mode)
  // torchLights stays empty, animateTorches() will just do nothing
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CARD GALLERY â€” NORTH WALL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const cardMeshes = [];
let galleryPage = 0;
const CARD_W = 2.8, CARD_H = 3.8;
function getCardsPerPage(){ return settings.cardsPerPage || 5; }

const TYPE_COLORS = {
  creature:'#4488cc', spell:'#aa44cc', trap:'#cc4444',
  artifact:'#cc8844', enchantment:'#44aa66', hero:'#c9a84c', default:'#556688'
};

function cardTypeColor(type=''){
  const t=type.toLowerCase();
  for(const [k,v] of Object.entries(TYPE_COLORS)){if(t.includes(k))return v;}
  return TYPE_COLORS.default;
}

function makeCardTexture(card){
  const w=160,h=224;
  const c2=document.createElement('canvas');c2.width=w;c2.height=h;
  const ctx=c2.getContext('2d');
  // Background gradient
  const grad=ctx.createLinearGradient(0,0,0,h);
  grad.addColorStop(0,'#1c2030');grad.addColorStop(1,'#0e1018');
  ctx.fillStyle=grad;ctx.fillRect(0,0,w,h);
  // Type color bar
  ctx.fillStyle=cardTypeColor(card.type||'');
  ctx.fillRect(0,0,w,8);
  // Gold border
  ctx.strokeStyle='#c9a84c';ctx.lineWidth=3;ctx.strokeRect(2,2,w-4,h-4);
  ctx.strokeStyle='rgba(201,168,76,0.3)';ctx.lineWidth=1;ctx.strokeRect(6,6,w-12,h-12);
  // Cost circle
  ctx.fillStyle='rgba(201,168,76,0.15)';
  ctx.beginPath();ctx.arc(w-22,22,14,0,Math.PI*2);ctx.fill();
  ctx.strokeStyle='#c9a84c';ctx.lineWidth=1.5;
  ctx.beginPath();ctx.arc(w-22,22,14,0,Math.PI*2);ctx.stroke();
  ctx.fillStyle='#e8c96a';ctx.font='bold 14px Cinzel,serif';
  ctx.textAlign='center';ctx.textBaseline='middle';
  ctx.fillText(String(card.cost||0),w-22,22);
  // Card name
  ctx.fillStyle='#d4cfc0';ctx.font='bold 11px Cinzel,serif';
  ctx.textAlign='left';ctx.textBaseline='top';
  const name=card.name||'Unknown';
  ctx.fillText(name.length>14?name.slice(0,13)+'â€¦':name, 10, 12);
  // Art area (color fill based on type)
  const artCol=cardTypeColor(card.type||'');
  ctx.fillStyle=artCol+'33';ctx.fillRect(10,36,w-20,80);
  ctx.strokeStyle=artCol+'88';ctx.lineWidth=1;ctx.strokeRect(10,36,w-20,80);
  // Type icon in art area
  const icons={creature:'ğŸ‰',spell:'âœ¨',trap:'âš ',artifact:'âš™',enchantment:'ğŸŒ€',hero:'âš”'};
  const t=(card.type||'').toLowerCase();
  let icon='ğŸƒ';
  for(const [k,v] of Object.entries(icons)){if(t.includes(k)){icon=v;break;}}
  ctx.font='32px serif';ctx.textAlign='center';ctx.textBaseline='middle';
  ctx.fillText(icon,w/2,76);
  // Type text
  ctx.fillStyle='#8a8878';ctx.font='9px Cinzel,serif';ctx.textAlign='center';
  ctx.fillText((card.type||'CARD').toUpperCase(),w/2,124);
  // Stats
  if(card.atk!==undefined||card.def!==undefined){
    ctx.fillStyle='rgba(201,168,76,0.1)';ctx.fillRect(10,132,w-20,28);
    ctx.strokeStyle='rgba(201,168,76,0.3)';ctx.lineWidth=1;ctx.strokeRect(10,132,w-20,28);
    ctx.fillStyle='#cc5555';ctx.font='bold 13px Cinzel,serif';
    ctx.textAlign='left';ctx.fillText('âš”'+String(card.atk||0),16,140);
    ctx.fillStyle='#4488cc';ctx.textAlign='right';
    ctx.fillText('ğŸ›¡'+String(card.def||0),w-14,140);
  }
  // Description
  if(card.desc||card.effect){
    const txt=card.desc||card.effect||'';
    ctx.fillStyle='#8a8878';ctx.font='8px Crimson Pro,serif';
    ctx.textAlign='left';ctx.textBaseline='top';
    const words=txt.split(' ');let line='',y2=166;
    for(const word of words){
      const test=line+word+' ';
      if(ctx.measureText(test).width>w-20&&line){ctx.fillText(line,10,y2);line=word+' ';y2+=11;if(y2>200)break;}
      else line=test;
    }
    if(y2<=200)ctx.fillText(line,10,y2);
  }
  return new THREE.CanvasTexture(c2);
}

function makeCardFrameMesh(card, x, y, z){
  // Frame (gold border)
  const frameMat = new THREE.MeshLambertMaterial({
    color: new THREE.Color(cardTypeColor(card.type||'')).lerp(new THREE.Color(0xc9a84c),.5)
  });
  const frame = new THREE.Group();

  // Card face
  const cardMat = new THREE.MeshLambertMaterial({map: makeCardTexture(card), side:THREE.FrontSide});
  const cardMesh = new THREE.Mesh(new THREE.PlaneGeometry(CARD_W, CARD_H), cardMat);

  // Backing plate (slight 3D pop)
  const backing = new THREE.Mesh(
    new THREE.BoxGeometry(CARD_W+0.2, CARD_H+0.2, 0.06),
    new THREE.MeshLambertMaterial({color:0x0a0c14})
  );
  backing.position.z = -0.04;

  // Gold frame strips
  const fmat = new THREE.MeshLambertMaterial({color:0xc9a84c});
  [[CARD_W+0.2, 0.08, 0, CARD_H/2+0.04],
   [CARD_W+0.2, 0.08, 0,-CARD_H/2-0.04],
   [0.08, CARD_H+0.2,-CARD_W/2-0.04, 0],
   [0.08, CARD_H+0.2, CARD_W/2+0.04, 0],
  ].forEach(([w2,h2,fx,fy])=>{
    const strip=new THREE.Mesh(new THREE.BoxGeometry(w2,h2,0.05),fmat);
    strip.position.set(fx,fy,0.02);frame.add(strip);
  });

  // Subtle glow plane behind card
  const glowMat = new THREE.MeshBasicMaterial({
    color: new THREE.Color(cardTypeColor(card.type||'')),
    transparent:true, opacity:0.08
  });
  const glow = new THREE.Mesh(new THREE.PlaneGeometry(CARD_W+0.5, CARD_H+0.5), glowMat);
  glow.position.z = -0.1;

  frame.add(glow, backing, cardMesh);
  frame.position.set(x, y, z + 0.1);
  frame.userData = {card, interactable:true, type:'card'};
  return frame;
}

function buildGallery(page=0){
  // Remove old card meshes
  cardMeshes.forEach(m=>{
    scene.remove(m);
    m.traverse(c=>{if(c.material)c.material.dispose();if(c.geometry)c.geometry.dispose();});
  });
  cardMeshes.length=0;

  let cards=[...forgeData.cards];
  if(!cards.length){
    // Placeholder cards
    cards=[
      {id:'demo1',name:'Shadow Drake',type:'Creature',cost:4,atk:3,def:2,desc:'Flying. Deals 1 damage on enter.'},
      {id:'demo2',name:'Arcane Bolt',type:'Spell',cost:2,desc:'Deal 3 damage to any target.'},
      {id:'demo3',name:'Iron Shield',type:'Artifact',cost:3,def:4,desc:'Shield. +2 DEF to holder.'},
      {id:'demo4',name:'Vine Trap',type:'Trap',cost:1,desc:'Freeze attacker for 1 turn.'},
      {id:'demo5',name:'Forest Sage',type:'Creature',cost:5,atk:2,def:5,desc:'Regen. Draw a card each turn.'},
      {id:'demo6',name:'Lightning',type:'Spell',cost:3,desc:'Deal 5 damage. Piercing.'},
      {id:'demo7',name:'The Wanderer',type:'Hero',cost:6,atk:4,def:4,desc:'Haste. Lifesteal.'},
    ];
  }
  if(settings.cardSort==='cost') cards.sort((a,b)=>(a.cost||0)-(b.cost||0));
  else if(settings.cardSort==='type') cards.sort((a,b)=>(a.type||'').localeCompare(b.type||''));
  else cards.sort((a,b)=>(a.name||'').localeCompare(b.name||''));

  const cpp = getCardsPerPage();
  const rows = Math.max(1, settings.cardRows || 1);
  const cols = Math.ceil(cpp / rows);

  const start = page * cpp;
  const pageCards = cards.slice(start, start+cpp);
  const totalPages = Math.ceil(cards.length/cpp);

  const spacing = 3.4;
  const rowSpacing = 4.2;
  const totalW = (cols-1)*spacing;
  const startX = -totalW/2;

  pageCards.forEach((card,i)=>{
    const col = i % cols;
    const row = Math.floor(i / cols);
    const x = startX + col*spacing;
    const y = ROOM_H/2 + 0.2 - row*rowSpacing*(rows>1?0.8:0);
    const z = -ROOM_D/2 + 0.15;
    const m = makeCardFrameMesh(card, x, y, z);
    scene.add(m);
    cardMeshes.push(m);
  });

  // Update wall nav label
  const lbl = document.getElementById('wallNavLabel');
  if(lbl) lbl.textContent = `PAGE ${page+1}/${totalPages} Â· ${cards.length} CARDS`;
  galleryPage = page;
  return totalPages;
}

function galleryScroll(dir){
  loadForgeData();
  const cards = forgeData.cards.length ? forgeData.cards : [{},{},{},{},{},{},{}];
  const cpp = getCardsPerPage();
  const total = Math.ceil(cards.length/cpp);
  const next = ((galleryPage+dir)+total)%total;
  buildGallery(next);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TABLE (center) â€” PHASE 4
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let tableMesh;
let tableCardMeshes = [];   // mini cards on table surface
let diceMesh = null;        // d6 on table
let diceRolling = false;
let diceRollT = 0;
let diceRollResult = 1;

function buildTable(){
  const tableGroup = new THREE.Group();
  // Table top
  const top = new THREE.Mesh(
    new THREE.BoxGeometry(6,0.15,4),
    new THREE.MeshLambertMaterial({color:0x1a5c2a})
  );
  top.position.y=0.9; top.receiveShadow=true;
  tableGroup.add(top);
  // Felt surface detail
  const felt = new THREE.Mesh(
    new THREE.PlaneGeometry(5.7,3.7),
    new THREE.MeshLambertMaterial({color:0x165022})
  );
  felt.rotation.x=-Math.PI/2;felt.position.y=0.978;
  tableGroup.add(felt);
  // Table legs
  [[-2.8,0,-1.8],[-2.8,0,1.8],[2.8,0,-1.8],[2.8,0,1.8]].forEach(([x,y,z])=>{
    const leg=new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.12,0.9,8),matWood);
    leg.position.set(x,0.45,z);tableGroup.add(leg);
  });
  // Gold trim on table edge
  const trim=new THREE.Mesh(
    new THREE.BoxGeometry(6.1,0.05,4.1),
    new THREE.MeshLambertMaterial({color:0x8b6228})
  );
  trim.position.y=0.97;tableGroup.add(trim);

  tableGroup.position.set(0,0,2);
  // Table group itself is interactable for "open playtest"
  tableGroup.userData={interactable:true,type:'table',label:'Open Playtest'};
  tableMesh=tableGroup;
  scene.add(tableGroup);

  // Subtle light over table
  const tableLight=new THREE.PointLight(0x446633, 0.8, 6);
  tableLight.position.set(0,3,2);scene.add(tableLight);

  // Build dice and card spread after table is placed
  buildDice();
  buildTableCardSpread();
}

// â”€â”€ Dice (d6) on table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function makeDiceTexture(face){
  // face 1-6 â€” simple white dots on dark bg
  const c2=document.createElement('canvas');c2.width=64;c2.height=64;
  const ctx=c2.getContext('2d');
  ctx.fillStyle='#1a1a2e';ctx.beginPath();
  ctx.roundRect(2,2,60,60,10);ctx.fill();
  ctx.strokeStyle='rgba(201,168,76,0.6)';ctx.lineWidth=1.5;
  ctx.beginPath();ctx.roundRect(2,2,60,60,10);ctx.stroke();
  ctx.fillStyle='#e8c96a';
  const dots={
    1:[[32,32]],
    2:[[18,18],[46,46]],
    3:[[18,18],[32,32],[46,46]],
    4:[[18,18],[46,18],[18,46],[46,46]],
    5:[[18,18],[46,18],[32,32],[18,46],[46,46]],
    6:[[18,14],[46,14],[18,32],[46,32],[18,50],[46,50]],
  };
  (dots[face]||dots[1]).forEach(([x,y])=>{
    ctx.beginPath();ctx.arc(x,y,6,0,Math.PI*2);ctx.fill();
  });
  return new THREE.CanvasTexture(c2);
}

function buildDice(){
  // Create d6 as a BoxGeometry with per-face materials
  const faces = [1,6,2,5,3,4]; // standard d6 opposite-faces-sum-7
  const mats = faces.map(f=>new THREE.MeshLambertMaterial({map:makeDiceTexture(f)}));
  const geo = new THREE.BoxGeometry(0.35,0.35,0.35);
  diceMesh = new THREE.Mesh(geo, mats);
  diceMesh.position.set(2.2, 1.21, 1.2);  // top-right area of table
  diceMesh.userData = {
    interactable:true, type:'dice',
    label:'Roll Dice [TAP â¬¡]'
  };
  scene.add(diceMesh);
}

function rollDice(sides=6){
  if(diceRolling) return;
  diceRolling = true;
  diceRollT = 0;
  diceRollResult = Math.floor(Math.random()*sides)+1;

  // Show dice spin animation (handled in animateTable)
  const el = document.getElementById('diceResult');
  const numEl = document.getElementById('diceNum');
  const lblEl = document.getElementById('diceLabel');
  numEl.textContent = '?';
  lblEl.textContent = `D${sides}`;
  el.classList.add('show');

  // Tumble, then reveal
  let ticks = 0;
  const interval = setInterval(()=>{
    ticks++;
    numEl.textContent = Math.floor(Math.random()*sides)+1;
    if(ticks >= 8){
      clearInterval(interval);
      numEl.textContent = diceRollResult;
      diceRolling = false;
      toast(`ğŸ² Rolled ${diceRollResult} on D${sides}`, 'good');
      setTimeout(()=>el.classList.remove('show'), 2200);
    }
  }, 80);
}

// â”€â”€ Card spread on table surface â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildTableCardSpread(){
  // Remove old spread
  tableCardMeshes.forEach(m=>{
    scene.remove(m);
    if(m.material?.map) m.material.map.dispose();
    m.material?.dispose();
    m.geometry?.dispose();
  });
  tableCardMeshes = [];

  loadForgeData();
  let cards = forgeData.cards;
  // Try to get active deck
  let spreadCards = [];
  try{
    const activeId = localStorage.getItem('cardforge_active_layout');
    // active layout stores a layout, not a deck â€” use decks instead
    if(forgeData.decks && forgeData.decks.length){
      // Use first deck's card IDs to pull the spread
      const deck = forgeData.decks[0];
      const deckCardIds = deck.cards || deck.cardIds || [];
      if(deckCardIds.length){
        spreadCards = deckCardIds
          .map(id=>typeof id==='string'
            ? forgeData.cards.find(c=>c.id===id)
            : forgeData.cards.find(c=>c.id===id?.id||c.id===id))
          .filter(Boolean)
          .slice(0,7);
      }
    }
  }catch(e){}

  // Fallback: use first 5-7 cards
  if(!spreadCards.length && cards.length){
    spreadCards = cards.slice(0,Math.min(7,cards.length));
  }
  if(!spreadCards.length) return; // no cards = clean green felt

  // Lay cards in a slight fan/arc across the table top
  const count = spreadCards.length;
  const TABLE_Y = 0.99;  // just above felt (world coords: table is at y=0, top at y=0.9+0.09â‰ˆ0.99+tableGroup.y=0)
  // tableGroup is at (0,0,2), so table top world Y = 0.978+0 â‰ˆ 0.98
  const WORLD_Y = 0.98;
  const spreadW = Math.min(5.0, count * 0.75);
  const startX = -spreadW/2;
  const angleRange = count > 1 ? 0.25 : 0; // subtle fan spread

  spreadCards.forEach((card,i)=>{
    const t = count>1 ? i/(count-1) : 0.5;
    const x = startX + t*spreadW;
    const z = 2 + Math.sin(t*Math.PI)*0.2 - 0.3; // slight arc, table at z=2
    const angle = (t-0.5)*angleRange;

    // Mini card texture (smaller version of gallery card)
    const cw=80,ch=112;
    const c2=document.createElement('canvas');c2.width=cw;c2.height=ch;
    const ctx=c2.getContext('2d');
    const grad=ctx.createLinearGradient(0,0,0,ch);
    grad.addColorStop(0,'#1c2030');grad.addColorStop(1,'#0e1018');
    ctx.fillStyle=grad;ctx.fillRect(0,0,cw,ch);
    // Color bar
    ctx.fillStyle=cardTypeColor(card.type||'');
    ctx.fillRect(0,0,cw,5);
    // Gold border
    ctx.strokeStyle='#c9a84c';ctx.lineWidth=2;ctx.strokeRect(1,1,cw-2,ch-2);
    // Cost
    ctx.fillStyle='rgba(201,168,76,0.15)';ctx.beginPath();ctx.arc(cw-13,13,10,0,Math.PI*2);ctx.fill();
    ctx.strokeStyle='#c9a84c';ctx.lineWidth=1;ctx.beginPath();ctx.arc(cw-13,13,10,0,Math.PI*2);ctx.stroke();
    ctx.fillStyle='#e8c96a';ctx.font='bold 9px Cinzel,serif';ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(String(card.cost||0),cw-13,13);
    // Name
    ctx.fillStyle='#d4cfc0';ctx.font='bold 7px Cinzel,serif';ctx.textAlign='left';ctx.textBaseline='top';
    const name=card.name||'Unknown';
    ctx.fillText(name.length>10?name.slice(0,9)+'â€¦':name, 4, 8);
    // Type icon
    const icons={creature:'ğŸ‰',spell:'âœ¨',trap:'âš ',artifact:'âš™',enchantment:'ğŸŒ€',hero:'âš”'};
    const tp=(card.type||'').toLowerCase();
    let icon='ğŸƒ';for(const [k,v] of Object.entries(icons)){if(tp.includes(k)){icon=v;break;}}
    ctx.font='22px serif';ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(icon,cw/2,55);

    const tex = new THREE.CanvasTexture(c2);
    // Card face mesh â€” lay flat on table
    const CARD_SCALE_W = 0.55, CARD_SCALE_H = 0.77;
    const mat = new THREE.MeshLambertMaterial({map:tex,side:THREE.FrontSide});
    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(CARD_SCALE_W,CARD_SCALE_H),mat);
    mesh.rotation.x = -Math.PI/2;        // flat on table
    mesh.rotation.z = angle;
    mesh.position.set(x, WORLD_Y+0.001, z);
    mesh.userData = {
      interactable:true, type:'tableCard',
      card, label:`${card.name||'Card'} [TAP to inspect]`
    };
    scene.add(mesh);
    tableCardMeshes.push(mesh);

    // Thin backing shadow
    const shadowMat=new THREE.MeshBasicMaterial({color:0x000000,transparent:true,opacity:0.15});
    const shadow=new THREE.Mesh(new THREE.PlaneGeometry(CARD_SCALE_W+0.04,CARD_SCALE_H+0.04),shadowMat);
    shadow.rotation.x=-Math.PI/2;shadow.rotation.z=angle;
    shadow.position.set(x+0.02,WORLD_Y,z+0.02);
    scene.add(shadow);
    tableCardMeshes.push(shadow);
  });

  // Deck label card at top-left if deck name available
  if(forgeData.decks?.length){
    const deckName = forgeData.decks[0]?.name || 'ACTIVE DECK';
    const lc=document.createElement('canvas');lc.width=200;lc.height=40;
    const lctx=lc.getContext('2d');
    lctx.fillStyle='rgba(201,168,76,0.12)';lctx.fillRect(0,0,200,40);
    lctx.strokeStyle='rgba(201,168,76,0.4)';lctx.lineWidth=1;lctx.strokeRect(0,0,200,40);
    lctx.fillStyle='#a08040';lctx.font='bold 11px Cinzel,serif';lctx.textAlign='center';
    lctx.textBaseline='middle';
    lctx.fillText(deckName.slice(0,20).toUpperCase(),100,20);
    const ltex=new THREE.CanvasTexture(lc);
    const lm=new THREE.Mesh(new THREE.PlaneGeometry(1.9,0.38),new THREE.MeshBasicMaterial({map:ltex,transparent:true}));
    lm.rotation.x=-Math.PI/2;
    lm.position.set(-1.8, WORLD_Y+0.002, 3.5);
    scene.add(lm);
    tableCardMeshes.push(lm);
  }
}

// â”€â”€ Table animation (dice spin, card hover glow) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function animateTable(t){
  if(diceMesh){
    if(diceRolling){
      diceMesh.rotation.x += 0.18;
      diceMesh.rotation.y += 0.23;
      diceMesh.rotation.z += 0.09;
    } else {
      // Gentle idle bob
      diceMesh.position.y = 1.21 + Math.sin(t*1.2)*0.006;
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WALL LABELS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function makeLabelTexture(text, subtext=''){
  const c2=document.createElement('canvas');c2.width=512;c2.height=64;
  const ctx=c2.getContext('2d');
  ctx.clearRect(0,0,512,64);
  ctx.fillStyle='rgba(200,168,76,0.12)';ctx.fillRect(0,0,512,64);
  ctx.strokeStyle='rgba(160,120,40,0.45)';ctx.lineWidth=1;ctx.strokeRect(1,1,510,62);
  ctx.fillStyle='#7a5010';ctx.font='bold 22px Cinzel,serif';ctx.textAlign='center';
  ctx.textBaseline='middle';ctx.fillText(text,256,subtext?20:32);
  if(subtext){ctx.fillStyle='#a08040';ctx.font='12px Cinzel,serif';ctx.fillText(subtext,256,44);}
  return new THREE.CanvasTexture(c2);
}

function addWallLabels(){
  // North wall - Gallery label
  const galLabel=new THREE.Mesh(
    new THREE.PlaneGeometry(5,0.6),
    new THREE.MeshBasicMaterial({map:makeLabelTexture('âœ¦ CARD GALLERY','TAP A CARD TO INSPECT'),transparent:true})
  );
  galLabel.position.set(0,ROOM_H-0.5,-ROOM_D/2+0.15);scene.add(galLabel);

  // South wall - Chronicle panels label
  const chrLabel=new THREE.Mesh(
    new THREE.PlaneGeometry(5,0.6),
    new THREE.MeshBasicMaterial({map:makeLabelTexture('âœ¦ THE CHRONICLE','CHARACTERS Â· WORLD Â· BOOKS'),transparent:true})
  );
  chrLabel.rotation.y=Math.PI;chrLabel.position.set(0,ROOM_H-0.5,ROOM_D/2-0.15);scene.add(chrLabel);

  // East wall - Whiteboard
  const wbLabel=new THREE.Mesh(
    new THREE.PlaneGeometry(4,0.6),
    new THREE.MeshBasicMaterial({map:makeLabelTexture('âœ¦ WHITEBOARD I','PRESS DRAW TO SKETCH'),transparent:true})
  );
  wbLabel.rotation.y=-Math.PI/2;wbLabel.position.set(ROOM_W/2-0.15,ROOM_H-0.5,0);scene.add(wbLabel);

  // Table sign
  const tableSign=new THREE.Mesh(
    new THREE.PlaneGeometry(3.0,0.45),
    new THREE.MeshBasicMaterial({map:makeLabelTexture('PLAYTEST TABLE','TAP TABLE Â· ROLL DICE âœ¦ TAP D6'),transparent:true})
  );
  tableSign.position.set(0,2.0,0.05);tableSign.rotation.x=-0.2;scene.add(tableSign);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CHRONICLE PANELS â€” SOUTH WALL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CHRONICLE DATA HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const STORE_CHRONICLE = 'chronicle_data';

function getChronicleData(){
  try{ const s=localStorage.getItem(STORE_CHRONICLE); return s?JSON.parse(s):null; }
  catch(e){ return null; }
}

// Map our panel keys to lifeapp section IDs and display info
const CHRONICLE_TABS = [
  {
    label:'BOOK',      icon:'ğŸ“–', key:'book',     sec:'book',
    color:'#cc8844',
    preview: d => {
      const books = d?.books||[];
      const active = books.find(b=>b.id===d?.activeBookId)||books[0];
      const chapters = active?.chapters?.length||0;
      return { count: active?.title||'No book yet', items: [`${chapters} chapter${chapters!==1?'s':''}`] };
    }
  },
  {
    label:'COMIC',     icon:'ğŸ¨', key:'comic',    sec:'comic',
    color:'#cc4488',
    preview: d => {
      return { count: 'Comics & Storyboards', items: ['Pages','Panels','Scripts'] };
    }
  },
  {
    label:'RPG',       icon:'âš”', key:'rpg',      sec:'rpg',
    color:'#8855cc',
    preview: d => {
      return { count: 'RPG World & Playtest', items: ['Maps','Characters','Sessions'] };
    }
  },
  {
    label:'BOARD',     icon:'ğŸ“‹', key:'board',    sec:'board',
    color:'#44aa66',
    preview: d => {
      return { count: 'Board Game Design', items: ['Rules','Components','Playtests'] };
    }
  },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CHRONICLE PANELS â€” SOUTH WALL (Phase 3 â€” live data)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const chroniclePanelMeshes = [];

function makeChroniclePanel(tab, x){
  const chrData = getChronicleData();
  const preview = tab.preview(chrData);

  const W=220, H=310;
  const c2=document.createElement('canvas');c2.width=W;c2.height=H;
  const ctx=c2.getContext('2d');

  // Background â€” clean white gallery card
  ctx.fillStyle='#fafaf8';ctx.fillRect(0,0,W,H);

  // Top colour band
  ctx.fillStyle=tab.color;ctx.fillRect(0,0,W,7);

  // Subtle drop shadow simulation
  ctx.fillStyle='rgba(0,0,0,0.05)';ctx.fillRect(3,3,W-3,H-3);
  ctx.fillStyle='#fafaf8';ctx.fillRect(0,0,W-3,H-3);

  // Border
  ctx.strokeStyle=tab.color+'55';ctx.lineWidth=1.5;ctx.strokeRect(1,1,W-2,H-2);

  // Icon circle
  ctx.fillStyle=tab.color+'18';
  ctx.beginPath();ctx.arc(W/2,58,34,0,Math.PI*2);ctx.fill();
  ctx.strokeStyle=tab.color+'44';ctx.lineWidth=1;
  ctx.beginPath();ctx.arc(W/2,58,34,0,Math.PI*2);ctx.stroke();
  ctx.font='30px serif';ctx.textAlign='center';ctx.textBaseline='middle';
  ctx.fillText(tab.icon,W/2,58);

  // Tab label
  ctx.fillStyle='#3a3020';ctx.font='bold 13px Cinzel,serif';
  ctx.textBaseline='top';ctx.fillText(tab.label,W/2,103);

  // Divider
  ctx.strokeStyle=tab.color+'44';ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(20,126);ctx.lineTo(W-20,126);ctx.stroke();

  // Count / title line
  ctx.fillStyle=tab.color;ctx.font='bold 10px Cinzel,serif';
  const countText = preview.count.length>24 ? preview.count.slice(0,22)+'â€¦' : preview.count;
  ctx.fillText(countText,W/2,133);

  // Preview items
  ctx.fillStyle='#6a6050';ctx.font='10px Crimson Pro,serif';
  ctx.textBaseline='top';
  (preview.items||[]).slice(0,4).forEach((item,i)=>{
    const txt = String(item||'').slice(0,26);
    ctx.fillStyle = i===0?'#4a4038':'#7a7060';
    ctx.fillText(txt, W/2, 155 + i*22);
  });

  // Tap hint at bottom
  ctx.fillStyle=tab.color+'66';
  ctx.fillRect(0, H-30, W, 30);
  ctx.fillStyle=tab.color;ctx.font='bold 8px Cinzel,serif';
  ctx.textBaseline='middle';
  ctx.fillText('TAP TO OPEN  â–¶', W/2, H-15);

  const tex = new THREE.CanvasTexture(c2);
  const mat = new THREE.MeshLambertMaterial({map:tex, side:THREE.FrontSide});
  const panel = new THREE.Mesh(new THREE.PlaneGeometry(2.4,3.2), mat);
  panel.rotation.y = Math.PI;
  panel.position.set(x, ROOM_H/2+0.1, ROOM_D/2-0.15);
  panel.userData = {interactable:true, type:'chronicle', tab:tab.key, sec:tab.sec, label:`Open ${tab.label}`};
  scene.add(panel);
  chroniclePanelMeshes.push({mesh:panel, mat, tab});

  // Frame â€” thin gold border
  const fmat = new THREE.MeshLambertMaterial({
    color: new THREE.Color(tab.color).lerp(new THREE.Color(0xc9a84c), 0.5)
  });
  [[2.55,0.06,0,1.65],[2.55,0.06,0,-1.65],[0.06,3.35,-1.28,0],[0.06,3.35,1.28,0]].forEach(([w2,h2,fx,fy])=>{
    const strip = new THREE.Mesh(new THREE.BoxGeometry(w2,h2,0.04), fmat);
    strip.rotation.y = Math.PI;
    strip.position.set(x+fx, ROOM_H/2+0.1+fy, ROOM_D/2-0.18);
    scene.add(strip);
  });

  // Subtle backing shadow plane
  const shadowMat = new THREE.MeshBasicMaterial({color:0x000000,transparent:true,opacity:0.06});
  const shadow = new THREE.Mesh(new THREE.PlaneGeometry(2.6,3.4), shadowMat);
  shadow.rotation.y = Math.PI;
  shadow.position.set(x+0.06, ROOM_H/2+0.0, ROOM_D/2-0.1);
  scene.add(shadow);
}

function buildChroniclePanels(){
  const xs = [-7, -2.4, 2.4, 7];
  CHRONICLE_TABS.forEach((tab,i) => makeChroniclePanel(tab, xs[i]));
}

// Refresh panel textures when Chronicle data changes
function refreshChroniclePanels(){
  // Rebuild panel textures in place
  const chrData = getChronicleData();
  chroniclePanelMeshes.forEach(({mesh, mat, tab})=>{
    const preview = tab.preview(chrData);
    const W=220,H=310;
    const c2=document.createElement('canvas');c2.width=W;c2.height=H;
    const ctx=c2.getContext('2d');
    ctx.fillStyle='#fafaf8';ctx.fillRect(0,0,W,H);
    ctx.fillStyle=tab.color;ctx.fillRect(0,0,W,7);
    ctx.strokeStyle=tab.color+'55';ctx.lineWidth=1.5;ctx.strokeRect(1,1,W-2,H-2);
    ctx.fillStyle=tab.color+'18';ctx.beginPath();ctx.arc(W/2,58,34,0,Math.PI*2);ctx.fill();
    ctx.font='30px serif';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(tab.icon,W/2,58);
    ctx.fillStyle='#3a3020';ctx.font='bold 13px Cinzel,serif';ctx.textBaseline='top';ctx.fillText(tab.label,W/2,103);
    ctx.strokeStyle=tab.color+'44';ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(20,126);ctx.lineTo(W-20,126);ctx.stroke();
    ctx.fillStyle=tab.color;ctx.font='bold 10px Cinzel,serif';
    const ct=(preview.count||'').length>24?(preview.count||'').slice(0,22)+'â€¦':preview.count||'';
    ctx.fillText(ct,W/2,133);
    ctx.font='10px Crimson Pro,serif';ctx.textBaseline='top';
    (preview.items||[]).slice(0,4).forEach((item,i2)=>{
      ctx.fillStyle=i2===0?'#4a4038':'#7a7060';ctx.fillText(String(item||'').slice(0,26),W/2,155+i2*22);
    });
    ctx.fillStyle=tab.color+'66';ctx.fillRect(0,H-30,W,30);
    ctx.fillStyle=tab.color;ctx.font='bold 8px Cinzel,serif';ctx.textBaseline='middle';
    ctx.fillText('TAP TO OPEN  â–¶',W/2,H-15);
    mat.map = new THREE.CanvasTexture(c2);
    mat.map.needsUpdate=true;mat.needsUpdate=true;
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CHRONICLE IFRAME SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let chrCurrentSec = 'calendar';
let chrFrameLoaded = false;

function openChronicle(sec){
  sec = sec || 'book';
  chrCurrentSec = sec;

  // Update tab bar active state
  document.querySelectorAll('.chr-tab-btn').forEach(b=>{
    b.classList.toggle('active', b.dataset.sec===sec);
  });

  const overlay = document.getElementById('chronicleOverlay');
  const frame   = document.getElementById('chronicleFrame');
  const loading = document.getElementById('chronicleLoading');

  overlay.classList.add('open');
  loading.classList.remove('hidden');
  chrFrameLoaded = false;

  // If frame is already loaded to lifeapp.html, just postMessage to switch tab
  if(frame.src && frame.src.includes('lifeapp.html') && frame.contentWindow){
    try{
      frame.contentWindow.postMessage({type:'forgeroom_nav', section: sec}, '*');
      setTimeout(()=>loading.classList.add('hidden'), 300);
      chrFrameLoaded = true;
      return;
    }catch(e){}
  }

  // Fresh load
  frame.onload = ()=>{
    chrFrameLoaded = true;
    // Wait for lifeapp to finish its own init, then navigate
    setTimeout(()=>{
      try{
        frame.contentWindow.postMessage({type:'forgeroom_nav', section: sec}, '*');
      }catch(e){}
      loading.classList.add('hidden');
    }, 800);
  };
  frame.src = 'lifeapp.html';
}

function chrSwitchTab(btn, sec){
  document.querySelectorAll('.chr-tab-btn').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  chrCurrentSec = sec;
  const frame = document.getElementById('chronicleFrame');
  if(chrFrameLoaded && frame.contentWindow){
    try{
      frame.contentWindow.postMessage({type:'forgeroom_nav', section: sec}, '*');
    }catch(e){
      // iframe blocked postMessage â€” reload with hash
      frame.src = 'lifeapp.html#'+sec;
    }
  }
}

function chrClose(){
  document.getElementById('chronicleOverlay').classList.remove('open');
  // Refresh panels with any data changes made in iframe
  setTimeout(refreshChroniclePanels, 200);
}

// Listen for messages back from Chronicle iframe
window.addEventListener('message', e=>{
  if(e.data?.type === 'forgeroom_section_changed'){
    const sec = e.data.section;
    document.querySelectorAll('.chr-tab-btn').forEach(b=>{
      b.classList.toggle('active', b.dataset.sec===sec);
    });
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RAYCASTING â€” INTERACTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const raycaster = new THREE.Raycaster();
const centerScreen = new THREE.Vector2(0,0);
let hoveredObj = null;
const hintEl = document.getElementById('hint');
const roomLabelEl = document.getElementById('roomlabel');

function getRoomLabel(){
  const p = camera.position;
  const angle = Math.atan2(p.x, p.z) * 180/Math.PI;
  if(p.z < -ROOM_D/2+3) return 'CARD GALLERY â€” NORTH';
  if(p.z > ROOM_D/2-3) return 'CHRONICLE PANELS â€” SOUTH';
  if(p.x > ROOM_W/2-3) return 'WHITEBOARD â€” EAST';
  if(p.x < -ROOM_W/2+3) return 'WHITEBOARD â€” WEST';
  return 'WORKSHOP â€” CENTER';
}

function checkInteraction(){
  raycaster.setFromCamera(centerScreen, camera);
  const interactables = [];
  scene.traverse(obj=>{if(obj.userData?.interactable)interactables.push(obj);});
  const hits = raycaster.intersectObjects(interactables, true);
  if(hits.length){
    const obj = hits[0].object;
    let target = obj;
    while(target.parent && !target.userData?.interactable) target=target.parent;
    if(target.userData?.interactable){
      hoveredObj=target;
      hintEl.textContent=(target.userData.label||'Interact') + ' [TAP â¬¡]';
      hintEl.classList.add('show');
      return;
    }
  }
  hoveredObj=null;
  hintEl.classList.remove('show');
}

function triggerInteract(){
  if(hoveredObj){
    doInteract(hoveredObj);
  }
}

function doInteract(obj){
  if(!obj?.userData) return;
  const {type, card, tab} = obj.userData;
  if(type==='card') openCardModal(card||obj.userData);
  else if(type==='tableCard') openCardModal(obj.userData.card||obj.userData);
  else if(type==='table') openPlaytest();
  else if(type==='dice') rollDice(6);
  else if(type==='chronicle') openChronicle(obj.userData.sec||obj.userData.tab||'book');
}

// Tap on canvas
canvas.addEventListener('click', e=>{
  if(drawMode) return;
  raycaster.setFromCamera(centerScreen, camera);
  const interactables=[];
  scene.traverse(obj=>{if(obj.userData?.interactable)interactables.push(obj);});
  const hits=raycaster.intersectObjects(interactables,true);
  if(hits.length){
    let t=hits[0].object;
    while(t.parent&&!t.userData?.interactable)t=t.parent;
    if(t.userData?.interactable)doInteract(t);
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MODAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function openCardModal(card){
  if(!card||!card.id)return;
  const el=document.getElementById('modalBody');
  const kws=card.keywords||card.kws||[];
  el.innerHTML=`
    <div class="card-detail-frame">
      <div class="card-detail-header">
        <div>
          <div class="card-detail-name">${esc(card.name||'Unknown')}</div>
          <div class="card-detail-type">${esc((card.type||'CARD').toUpperCase())}</div>
        </div>
        <div class="card-detail-cost">${card.cost||0}</div>
      </div>
      <div class="card-detail-body">
        ${(card.atk!==undefined||card.def!==undefined)?`
        <div class="card-stat-row">
          ${card.atk!==undefined?`<div class="card-stat"><div class="sv" style="color:#cc5555">âš” ${card.atk}</div><div class="sl">ATTACK</div></div>`:''}
          ${card.def!==undefined?`<div class="card-stat"><div class="sv" style="color:#4488cc">ğŸ›¡ ${card.def}</div><div class="sl">DEFENSE</div></div>`:''}
          ${card.hp!==undefined?`<div class="card-stat"><div class="sv" style="color:#44aa66">â™¥ ${card.hp}</div><div class="sl">HP</div></div>`:''}
        </div>`:''}
        ${kws.length?`<div class="card-kw-list">${kws.map(k=>`<span class="card-kw">${esc(k)}</span>`).join('')}</div>`:''}
        ${card.desc||card.effect?`<div class="card-desc">${esc(card.desc||card.effect||'')}</div>`:''}
      </div>
    </div>
    <div style="display:flex;gap:8px;">
      <button class="hbtn" style="flex:1;padding:10px;" onclick="window.location.href='forge.html'">âœ Edit in Forge</button>
      <button class="hbtn" style="flex:1;padding:10px;" onclick="closeModal()">Close</button>
    </div>`;
  document.getElementById('modal').classList.add('open');
}

function openPlaytest(){
  const overlay  = document.getElementById('playtestOverlay');
  const frame    = document.getElementById('playtestFrame');
  const loading  = document.getElementById('playtestLoading');

  overlay.classList.add('open');
  loading.classList.remove('hidden');

  // If already loaded, just show
  if(frame.src && frame.src.includes('playtest.html')){
    setTimeout(()=>loading.classList.add('hidden'), 200);
    return;
  }

  frame.onload = ()=>{
    loading.classList.add('hidden');
  };
  frame.src = 'playtest.html';
}

function closePlatyest(){
  document.getElementById('playtestOverlay').classList.remove('open');
}

function closeModal(){document.getElementById('modal').classList.remove('open');}
function esc(s){return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SETTINGS PANEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function openSettings(){
  const el=document.getElementById('modalBody');
  el.innerHTML=`
    <div style="font-family:'Cinzel',serif;font-size:13px;color:var(--gold2);letter-spacing:.12em;margin-bottom:16px;">âš™ ROOM SETTINGS</div>
    <div class="settings-row">
      <div><div class="settings-label">CAMERA FOV</div><div class="settings-sub">Field of view (${settings.fov}Â°)</div></div>
      <input type="range" min="55" max="100" value="${settings.fov}" oninput="settings.fov=+this.value;camera.fov=+this.value;camera.updateProjectionMatrix();this.previousElementSibling.children[1].textContent='Field of view ('+this.value+'Â°)'">
    </div>
    <div class="settings-row">
      <div><div class="settings-label">LOOK SENSITIVITY</div><div class="settings-sub">${settings.sensitivity}</div></div>
      <input type="range" min="0.5" max="6" step="0.1" value="${settings.sensitivity}" oninput="settings.sensitivity=+this.value;this.previousElementSibling.children[1].textContent=this.value">
    </div>
    <div class="settings-row">
      <div><div class="settings-label">MOVE SPEED</div><div class="settings-sub">${settings.speed}</div></div>
      <input type="range" min="1" max="10" step="0.5" value="${settings.speed}" oninput="settings.speed=+this.value;this.previousElementSibling.children[1].textContent=this.value">
    </div>
    <div class="settings-row">
      <div><div class="settings-label">INVERT Y LOOK</div></div>
      <div class="toggle-sw ${settings.invertY?'on':''}" onclick="this.classList.toggle('on');settings.invertY=this.classList.contains('on')"></div>
    </div>
    <div class="settings-row">
      <div><div class="settings-label">VIRTUAL JOYSTICK</div></div>
      <div class="toggle-sw ${settings.showJoystick?'on':''}" onclick="this.classList.toggle('on');settings.showJoystick=this.classList.contains('on');updateJoystickVisibility()"></div>
    </div>
    <div class="settings-row">
      <div><div class="settings-label">PERFORMANCE MODE</div><div class="settings-sub">Lower quality, better FPS</div></div>
      <div class="toggle-sw ${settings.perfMode?'on':''}" onclick="this.classList.toggle('on');settings.perfMode=this.classList.contains('on')"></div>
    </div>
    <div class="settings-row">
      <div><div class="settings-label">CARD SORT</div></div>
      <select onchange="settings.cardSort=this.value;buildGallery(0)">
        <option value="name" ${settings.cardSort==='name'?'selected':''}>By Name</option>
        <option value="cost" ${settings.cardSort==='cost'?'selected':''}>By Cost</option>
        <option value="type" ${settings.cardSort==='type'?'selected':''}>By Type</option>
      </select>
    </div>
    <div class="settings-row">
      <div><div class="settings-label">CARDS PER ROW</div><div class="settings-sub">${settings.cardsPerPage||5} cards shown</div></div>
      <select onchange="settings.cardsPerPage=+this.value;buildGallery(0);this.previousElementSibling.children[1].textContent=this.value+' cards shown'">
        <option value="3" ${(settings.cardsPerPage||5)===3?'selected':''}>3 â€” Fewer, Larger</option>
        <option value="5" ${(settings.cardsPerPage||5)===5?'selected':''}>5 â€” Default</option>
        <option value="8" ${(settings.cardsPerPage||5)===8?'selected':''}>8 â€” More Cards</option>
        <option value="10" ${(settings.cardsPerPage||5)===10?'selected':''}>10 â€” Many Cards</option>
      </select>
    </div>
    <div class="settings-row">
      <div><div class="settings-label">GAMEPAD DEADZONE</div><div class="settings-sub">${settings.deadzone}</div></div>
      <input type="range" min="0.05" max="0.35" step="0.01" value="${settings.deadzone}" oninput="settings.deadzone=+this.value;this.previousElementSibling.children[1].textContent=this.value">
    </div>
    <div style="margin-top:16px;display:flex;gap:8px;">
      <button class="hbtn" style="flex:1;padding:10px;" onclick="saveSettings();closeModal();toast('Settings saved','good')">âœ“ Save Settings</button>
      <button class="hbtn" style="flex:1;padding:10px;" onclick="if(deferredInstallPrompt){closeModal();doInstall();}else{toast('Already installed or use browser Add to Home Screen','good');}">ğŸ“² Install</button>
      <button class="hbtn" style="flex:1;padding:10px;" onclick="closeModal()">Cancel</button>
    </div>
    <div style="margin-top:12px;border-top:1px solid var(--border);padding-top:12px;">
      <div style="font-family:'Cinzel',serif;font-size:10px;color:var(--text2);letter-spacing:.1em;margin-bottom:8px;">GAMEPAD BUTTONS (GameSir G8+)</div>
      <div style="font-size:11px;color:var(--text2);line-height:1.9;">
        Left Stick â€” Move &nbsp;|&nbsp; Right Stick â€” Look<br>
        A â€” Interact &nbsp;|&nbsp; B â€” Back/Close<br>
        Y â€” Toggle Draw Mode &nbsp;|&nbsp; X â€” Jump to Gallery<br>
        LT â€” Sprint &nbsp;|&nbsp; Start â€” Settings
      </div>
    </div>`;
  document.getElementById('modal').classList.add('open');
}

function updateJoystickVisibility(){
  const v=settings.showJoystick;
  document.getElementById('vjLeft').style.display=v?'flex':'none';
  document.getElementById('vjRight').style.display=v?'flex':'none';
  document.getElementById('vjLabel').style.display=v?'block':'none';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WHITEBOARD SYSTEM â€” PHASE 2 + PAN/ZOOM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let drawMode = false;

// Wall aspect ratio: ROOM_D(24) x ROOM_H(6) = 4:1 landscape
const WB_ASPECT = 24 / 6; // 4.0 â€” width:height of the actual wall
const WB_CANVAS_HEIGHT = 1200; // fixed internal canvas height
const WB_CANVAS_WIDTH = Math.round(WB_CANVAS_HEIGHT * WB_ASPECT); // 4800

// State
const WB = {
  wall: 'east',
  color: '#d4cfc0',
  size: 5,
  erasing: false,
  panMode: false,
  drawing: false,
  panning: false,
  lastX: 0,
  lastY: 0,
  // Pan/zoom
  zoom: 1.0,
  panX: 0,
  panY: 0,
  panStartX: 0,
  panStartY: 0,
  undoStack: [],
  maxUndo: 20,
  saveTimer: null,
  penActive: false,
  dirty: false,
};

// Three.js texture references
let wbEastMaterial = null;
let wbWestMaterial = null;

const wbCanvas = document.getElementById('wbCanvas');
const wbCtx = wbCanvas.getContext('2d');
const wbViewport = document.getElementById('wbViewport');
const wbCursorEl = document.getElementById('wbCursor');
const wbSaveStatusEl = document.getElementById('wbSaveStatus');
const wbUndoCountEl = document.getElementById('wbUndoCount');

function wbUpdateTransform(){
  wbCanvas.style.transformOrigin = '0 0';
  wbCanvas.style.transform = `translate(${WB.panX}px,${WB.panY}px) scale(${WB.zoom})`;
  const pct = Math.round(WB.zoom * 100);
  const lbl = document.getElementById('wbZoomLabel');
  if(lbl) lbl.textContent = pct + '%';
}

function wbFitToView(){
  // Fit canvas into viewport maintaining aspect ratio
  const vw = wbViewport.clientWidth;
  const vh = wbViewport.clientHeight;
  const scaleX = vw / WB_CANVAS_WIDTH;
  const scaleY = vh / WB_CANVAS_HEIGHT;
  WB.zoom = Math.min(scaleX, scaleY);
  // Center it
  WB.panX = (vw - WB_CANVAS_WIDTH * WB.zoom) / 2;
  WB.panY = (vh - WB_CANVAS_HEIGHT * WB.zoom) / 2;
  wbUpdateTransform();
}

function wbZoom(factor){
  const vw = wbViewport.clientWidth;
  const vh = wbViewport.clientHeight;
  const cx = vw/2, cy = vh/2;
  const prevZoom = WB.zoom;
  WB.zoom = Math.max(0.1, Math.min(5.0, WB.zoom * factor));
  // Zoom toward center
  WB.panX = cx - (cx - WB.panX) * (WB.zoom / prevZoom);
  WB.panY = cy - (cy - WB.panY) * (WB.zoom / prevZoom);
  wbUpdateTransform();
}

function wbResetView(){
  wbFitToView();
}

function wbResize(){
  // Canvas is fixed size â€” just refit the view
  if(wbCanvas.width !== WB_CANVAS_WIDTH || wbCanvas.height !== WB_CANVAS_HEIGHT){
    // First time setup: size the canvas
    const saved = wbCanvas.width > 0 ? null : null; // will reload from storage
    wbCanvas.width = WB_CANVAS_WIDTH;
    wbCanvas.height = WB_CANVAS_HEIGHT;
    wbCanvas.style.width = WB_CANVAS_WIDTH + 'px';
    wbCanvas.style.height = WB_CANVAS_HEIGHT + 'px';
    wbCtx.fillStyle = '#0e1018';
    wbCtx.fillRect(0,0,WB_CANVAS_WIDTH,WB_CANVAS_HEIGHT);
    wbDrawGrid();
  }
  // Refit
  requestAnimationFrame(()=>wbFitToView());
}

function wbDrawGrid(){
  wbCtx.save();
  wbCtx.strokeStyle = 'rgba(42,47,69,0.4)';
  wbCtx.lineWidth = 1.5;
  const step = 80;
  for(let x=0;x<WB_CANVAS_WIDTH;x+=step){
    wbCtx.beginPath();wbCtx.moveTo(x,0);wbCtx.lineTo(x,WB_CANVAS_HEIGHT);wbCtx.stroke();
  }
  for(let y=0;y<WB_CANVAS_HEIGHT;y+=step){
    wbCtx.beginPath();wbCtx.moveTo(0,y);wbCtx.lineTo(WB_CANVAS_WIDTH,y);wbCtx.stroke();
  }
  wbCtx.fillStyle = 'rgba(201,168,76,0.12)';
  wbCtx.font = '22px Cinzel, serif';
  wbCtx.textAlign = 'right';
  wbCtx.textBaseline = 'bottom';
  wbCtx.fillText((WB.wall==='east'?'EAST':'WEST') + ' WALL', WB_CANVAS_WIDTH-24, WB_CANVAS_HEIGHT-20);
  wbCtx.restore();
}

function wbLoadSaved(){
  const key = STORE_WB(WB.wall);
  const saved = localStorage.getItem(key);
  wbCtx.fillStyle = '#0e1018';
  wbCtx.fillRect(0,0,WB_CANVAS_WIDTH,WB_CANVAS_HEIGHT);
  wbDrawGrid();
  if(saved){
    const img = new Image();
    img.onload = ()=>{
      wbCtx.drawImage(img, 0, 0, WB_CANVAS_WIDTH, WB_CANVAS_HEIGHT);
    };
    img.src = saved;
    wbSaveStatusEl.textContent = 'â— SAVED';
    wbSaveStatusEl.style.color = 'var(--green)';
  } else {
    wbSaveStatusEl.textContent = 'â—‹ EMPTY';
    wbSaveStatusEl.style.color = 'var(--text2)';
  }
  WB.undoStack = [];
  wbUndoCountEl.textContent = '0';
  WB.dirty = false;
}

function wbPushUndo(){
  WB.undoStack.push(wbCtx.getImageData(0,0,WB_CANVAS_WIDTH,WB_CANVAS_HEIGHT));
  if(WB.undoStack.length > WB.maxUndo) WB.undoStack.shift();
  wbUndoCountEl.textContent = WB.undoStack.length;
}

function wbUndo(){
  if(!WB.undoStack.length){ toast('Nothing to undo'); return; }
  wbCtx.putImageData(WB.undoStack.pop(), 0, 0);
  wbUndoCountEl.textContent = WB.undoStack.length;
  WB.dirty = true;
  wbScheduleSave();
}

function wbSetColor(el){
  document.querySelectorAll('.wb-color').forEach(e=>e.classList.remove('active'));
  el.classList.add('active');
  WB.color = el.dataset.color;
  WB.erasing = false;
  WB.panMode = false;
  wbCanvas.classList.remove('erasing','panning');
  document.getElementById('wbEraserBtn').classList.remove('active');
  document.getElementById('wbPanBtn').classList.remove('active');
}

function wbSetSize(el){
  document.querySelectorAll('.wb-size').forEach(e=>e.classList.remove('active'));
  el.classList.add('active');
  WB.size = parseInt(el.dataset.size);
  wbUpdateCursor();
}

function wbToggleEraser(){
  WB.erasing = !WB.erasing;
  if(WB.erasing) WB.panMode = false;
  wbCanvas.classList.toggle('erasing', WB.erasing);
  wbCanvas.classList.remove('panning');
  document.getElementById('wbEraserBtn').classList.toggle('active', WB.erasing);
  document.getElementById('wbPanBtn').classList.remove('active');
}

function wbTogglePan(){
  WB.panMode = !WB.panMode;
  if(WB.panMode){ WB.erasing = false; }
  wbCanvas.classList.toggle('panning', WB.panMode);
  wbCanvas.classList.remove('erasing');
  document.getElementById('wbPanBtn').classList.toggle('active', WB.panMode);
  document.getElementById('wbEraserBtn').classList.remove('active');
}

function wbUpdateCursor(){
  const sz = Math.max(WB.size * WB.zoom, 4);
  wbCursorEl.style.width  = sz + 'px';
  wbCursorEl.style.height = sz + 'px';
  wbCursorEl.style.borderColor = WB.erasing ? 'rgba(204,68,68,0.8)' : 'rgba(201,168,76,0.7)';
}

function wbScheduleSave(){
  wbSaveStatusEl.textContent = 'â— UNSAVED';
  wbSaveStatusEl.style.color = 'var(--gold)';
  clearTimeout(WB.saveTimer);
  WB.saveTimer = setTimeout(()=>wbSave(true), 800);
}

function wbSave(auto=false){
  const key = STORE_WB(WB.wall);
  const data = wbCanvas.toDataURL('image/jpeg', 0.75);
  try {
    localStorage.setItem(key, data);
    wbSaveStatusEl.textContent = auto ? 'âœ“ AUTO-SAVED' : 'âœ“ SAVED';
    wbSaveStatusEl.style.color = 'var(--green)';
    WB.dirty = false;
    wbApplyTextureToWall(WB.wall, data);
    if(!auto) toast('Whiteboard saved!', 'good');
  } catch(e){
    wbSaveStatusEl.textContent = 'âœ• SAVE FAILED (storage full?)';
    wbSaveStatusEl.style.color = 'var(--red)';
    toast('Save failed â€” storage may be full', 'bad');
  }
}

function wbExportPNG(){
  const data = wbCanvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = data;
  a.download = `forge-room-${WB.wall}-wall-${Date.now()}.png`;
  a.click();
  toast('PNG downloaded!', 'good');
}

function wbClear(){
  if(!confirm('Clear this whiteboard? This cannot be undone.')) return;
  wbPushUndo();
  wbCtx.fillStyle = '#0e1018';
  wbCtx.fillRect(0, 0, WB_CANVAS_WIDTH, WB_CANVAS_HEIGHT);
  wbDrawGrid();
  WB.undoStack = []; wbUndoCountEl.textContent = '0';
  WB.dirty = true;
  localStorage.removeItem(STORE_WB(WB.wall));
  wbApplyTextureToWall(WB.wall, null);
  wbSaveStatusEl.textContent = 'â—‹ CLEARED';
  wbSaveStatusEl.style.color = 'var(--text2)';
  toast('Whiteboard cleared');
}

function wbSwitchWall(){
  if(WB.dirty){ wbSave(true); }
  WB.wall = WB.wall === 'east' ? 'west' : 'east';
  document.getElementById('wbWallLabel').textContent = (WB.wall==='east'?'EAST':'WEST') + ' WALL';
  document.getElementById('wbWallBtn').textContent = WB.wall==='east' ? 'â†” SWITCH (â†’ WEST)' : 'â†” SWITCH (â†’ EAST)';
  wbLoadSaved();
  wbDrawGrid();
}

// Convert viewport coords to canvas coords
function wbViewToCanvas(vx, vy){
  const r = wbViewport.getBoundingClientRect();
  // vx,vy relative to viewport
  const rx = vx - r.left;
  const ry = vy - r.top;
  // Invert transform: subtract pan then divide by zoom
  const cx = (rx - WB.panX) / WB.zoom;
  const cy = (ry - WB.panY) / WB.zoom;
  return {x: cx, y: cy};
}

function wbStrokeStart(cx, cy){
  wbPushUndo();
  WB.drawing = true;
  WB.lastX = cx; WB.lastY = cy;
  wbCtx.beginPath();
  wbCtx.moveTo(cx, cy);
  if(WB.erasing){
    wbCtx.globalCompositeOperation = 'destination-out';
    wbCtx.lineWidth = WB.size * 2.5;
  } else {
    wbCtx.globalCompositeOperation = 'source-over';
    wbCtx.strokeStyle = WB.color;
    wbCtx.lineWidth = WB.size;
  }
  wbCtx.lineCap = 'round';
  wbCtx.lineJoin = 'round';
  wbCtx.arc(cx, cy, (WB.erasing ? WB.size*1.25 : WB.size/2), 0, Math.PI*2);
  wbCtx.fill();
  if(WB.erasing) wbCtx.fillStyle = 'rgba(0,0,0,1)';
  else wbCtx.fillStyle = WB.color;
  wbCtx.beginPath();
  wbCtx.moveTo(cx, cy);
}

function wbStrokeMove(cx, cy){
  if(!WB.drawing) return;
  const mx = (WB.lastX + cx) / 2;
  const my = (WB.lastY + cy) / 2;
  wbCtx.quadraticCurveTo(WB.lastX, WB.lastY, mx, my);
  wbCtx.stroke();
  wbCtx.beginPath();
  wbCtx.moveTo(mx, my);
  WB.lastX = cx; WB.lastY = cy;
  WB.dirty = true;
}

function wbStrokeEnd(){
  if(!WB.drawing) return;
  WB.drawing = false;
  wbCtx.globalCompositeOperation = 'source-over';
  wbScheduleSave();
}

function isPalmTouch(e){
  if(!WB.penActive) return false;
  if(e.pointerType === 'touch'){
    const size = Math.max(e.width||0, e.height||0);
    return size > 25;
  }
  return false;
}

// Two-finger pinch zoom state
const wbPinch = {active:false, ids:[], startDist:0, startZoom:1, midX:0, midY:0, startPanX:0, startPanY:0};

wbViewport.addEventListener('pointerdown', e=>{
  if(e.pointerType === 'pen') WB.penActive = true;
  if(isPalmTouch(e)) return;
  e.preventDefault();
  wbViewport.setPointerCapture(e.pointerId);

  // Track fingers for pinch
  if(e.pointerType === 'touch'){
    wbPinch.ids.push(e.pointerId);
    if(wbPinch.ids.length === 2){
      // Start pinch â€” cancel any drawing
      WB.drawing = false;
      wbPinch.active = true;
      return;
    }
    if(wbPinch.active) return;
  }

  if(WB.panMode){
    WB.panning = true;
    WB.panStartX = e.clientX - WB.panX;
    WB.panStartY = e.clientY - WB.panY;
    return;
  }

  const {x,y} = wbViewToCanvas(e.clientX, e.clientY);
  wbStrokeStart(x, y);
  wbCursorEl.style.display = 'block';
  wbCursorEl.style.left = e.clientX + 'px';
  wbCursorEl.style.top  = e.clientY + 'px';
  wbUpdateCursor();
}, {passive:false});

wbViewport.addEventListener('pointermove', e=>{
  if(isPalmTouch(e)) return;
  e.preventDefault();

  // Pinch zoom
  if(wbPinch.active && wbPinch.ids.length >= 2){
    // We'd need to track pointer positions â€” simplified: use gesturechange fallback
    return;
  }

  if(WB.panning){
    WB.panX = e.clientX - WB.panStartX;
    WB.panY = e.clientY - WB.panStartY;
    wbUpdateTransform();
    return;
  }

  const {x,y} = wbViewToCanvas(e.clientX, e.clientY);
  wbStrokeMove(x, y);
  wbCursorEl.style.left = e.clientX + 'px';
  wbCursorEl.style.top  = e.clientY + 'px';
}, {passive:false});

wbViewport.addEventListener('pointerup', e=>{
  if(e.pointerType === 'pen') WB.penActive = false;
  e.preventDefault();
  // Remove from pinch tracking
  const idx = wbPinch.ids.indexOf(e.pointerId);
  if(idx >= 0) wbPinch.ids.splice(idx, 1);
  if(wbPinch.ids.length < 2) wbPinch.active = false;

  WB.panning = false;
  wbStrokeEnd();
}, {passive:false});

wbViewport.addEventListener('pointercancel', e=>{
  WB.penActive = false;
  const idx = wbPinch.ids.indexOf(e.pointerId);
  if(idx >= 0) wbPinch.ids.splice(idx, 1);
  if(wbPinch.ids.length < 2) wbPinch.active = false;
  WB.panning = false;
  wbStrokeEnd();
});

wbViewport.addEventListener('pointerleave', ()=>{
  wbCursorEl.style.display = 'none';
  if(WB.drawing) wbStrokeEnd();
  WB.panning = false;
});

wbViewport.addEventListener('pointerenter', ()=>{
  wbCursorEl.style.display = 'block';
  wbUpdateCursor();
});

// Mouse wheel zoom
wbViewport.addEventListener('wheel', e=>{
  e.preventDefault();
  const factor = e.deltaY < 0 ? 1.1 : 0.9;
  // Zoom toward mouse pointer
  const r = wbViewport.getBoundingClientRect();
  const mx = e.clientX - r.left;
  const my = e.clientY - r.top;
  const prevZoom = WB.zoom;
  WB.zoom = Math.max(0.1, Math.min(5.0, WB.zoom * factor));
  WB.panX = mx - (mx - WB.panX) * (WB.zoom / prevZoom);
  WB.panY = my - (my - WB.panY) * (WB.zoom / prevZoom);
  wbUpdateTransform();
}, {passive:false});

// Apply drawing as 3D wall texture
function wbApplyTextureToWall(wall, dataURL){
  const mat = wall === 'east' ? wbEastMaterial : wbWestMaterial;
  if(!mat) return;
  if(!dataURL){
    mat.map = makeStoneTexture(256,256,false);
    mat.map.repeat.set(3,2);
    mat.map.needsUpdate = true;
    mat.emissive = new THREE.Color(0,0,0);
    mat.needsUpdate = true;
    return;
  }
  const img = new Image();
  img.onload = ()=>{
    const t = new THREE.Texture(img);
    t.needsUpdate = true;
    mat.map = t;
    mat.emissive = new THREE.Color(0.05, 0.04, 0.01);
    mat.needsUpdate = true;
  };
  img.src = dataURL;
}

function toggleDrawMode(){
  const angle = ((yaw * 180 / Math.PI) % 360 + 360) % 360;
  if(angle > 45 && angle < 135)       WB.wall = 'west';
  else if(angle > 225 && angle < 315) WB.wall = 'east';
  else WB.wall = 'east';
  wbOpen();
}

function wbOpen(wall=null){
  if(wall) WB.wall = wall;
  drawMode = true;
  document.getElementById('btnDraw').classList.add('active');
  document.getElementById('wbOverlay').classList.add('open');
  document.getElementById('wbWallLabel').textContent = (WB.wall==='east'?'EAST':'WEST') + ' WALL';
  document.getElementById('wbWallBtn').textContent = WB.wall==='east' ? 'â†” SWITCH (â†’ WEST)' : 'â†” SWITCH (â†’ EAST)';
  // Setup canvas if first time
  if(wbCanvas.width !== WB_CANVAS_WIDTH){
    wbCanvas.width = WB_CANVAS_WIDTH;
    wbCanvas.height = WB_CANVAS_HEIGHT;
    wbCanvas.style.width = WB_CANVAS_WIDTH + 'px';
    wbCanvas.style.height = WB_CANVAS_HEIGHT + 'px';
    wbCtx.fillStyle = '#0e1018';
    wbCtx.fillRect(0,0,WB_CANVAS_WIDTH,WB_CANVAS_HEIGHT);
    wbDrawGrid();
  }
  wbLoadSaved();
  requestAnimationFrame(()=>wbFitToView());
}

function wbClose(){
  if(WB.dirty) wbSave(true);
  drawMode = false;
  document.getElementById('btnDraw').classList.remove('active');
  document.getElementById('wbOverlay').classList.remove('open');
  wbCursorEl.style.display = 'none';
  WB.drawing = false;
  WB.panning = false;
  WB.penActive = false;
  wbPinch.ids = [];
  wbPinch.active = false;
}

window.addEventListener('resize', ()=>{
  if(drawMode) requestAnimationFrame(()=>wbFitToView());
});

function wbInitTextures(){
  ['east','west'].forEach(wall=>{
    const saved = localStorage.getItem(STORE_WB(wall));
    if(saved) wbApplyTextureToWall(wall, saved);
  });
}

function wbRegisterMaterials(eastMat, westMat){
  wbEastMaterial = eastMat;
  wbWestMaterial = westMat;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WALL JUMP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function jumpToWall(wall){
  const targets={
    north:{x:0,y:1.7,z:WALL_N+3, rx:0, ry:0},
    south:{x:0,y:1.7,z:WALL_S-3, rx:0, ry:Math.PI},
    east: {x:WALL_E-3,y:1.7,z:0, rx:0, ry:-Math.PI/2},
    west: {x:WALL_W+3,y:1.7,z:0, rx:0, ry:Math.PI/2},
    center:{x:0,y:1.7,z:3, rx:0, ry:0},
  };
  const t=targets[wall];if(!t)return;
  jumpTarget=t; jumpStart={x:camera.position.x,y:camera.position.y,z:camera.position.z,yaw:yaw,pitch:pitch};
  jumpT=0;
  if(wall==='north'){
    document.getElementById('wallNav').classList.add('show');
  } else {
    document.getElementById('wallNav').classList.remove('show');
  }
}

let jumpTarget=null, jumpStart=null, jumpT=1;
function doJump(delta){
  if(!jumpTarget||jumpT>=1)return;
  jumpT=Math.min(1,jumpT+delta*1.5);
  const t=jumpT<0.5?2*jumpT*jumpT:1-Math.pow(-2*jumpT+2,2)/2;
  camera.position.x=jumpStart.x+(jumpTarget.x-jumpStart.x)*t;
  camera.position.y=jumpStart.y+(jumpTarget.y-jumpStart.y)*t;
  camera.position.z=jumpStart.z+(jumpTarget.z-jumpStart.z)*t;
  yaw=jumpStart.yaw+(jumpTarget.ry-jumpStart.yaw)*t;
  pitch=jumpStart.pitch+(jumpTarget.rx-jumpStart.pitch)*t;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CAMERA CONTROL â€” LOOK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let yaw=Math.PI, pitch=0;
const euler = new THREE.Euler(0,0,0,'YXZ');

function applyCamera(){
  euler.set(pitch, yaw, 0);
  camera.quaternion.setFromEuler(euler);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VIRTUAL JOYSTICK SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const vjL={active:false,id:-1,startX:0,startY:0,dx:0,dy:0};
const vjR={active:false,id:-1,startX:0,startY:0,dx:0,dy:0};
const VJ_RADIUS=60;

function setupVirtualJoysticks(){
  const LEFT=document.getElementById('vjLeft');
  const RIGHT=document.getElementById('vjRight');
  const lKnob=document.getElementById('vjLKnob');
  const rKnob=document.getElementById('vjRKnob');

  function onStart(el,vj,knob,e){
    const touch=[...e.changedTouches].find(t=>{
      const r=el.getBoundingClientRect();
      return t.clientX>=r.left&&t.clientX<=r.right&&t.clientY>=r.top&&t.clientY<=r.bottom;
    });
    if(!touch||vj.active)return;
    vj.active=true;vj.id=touch.identifier;
    vj.startX=touch.clientX;vj.startY=touch.clientY;
    vj.dx=0;vj.dy=0;
  }
  function onMove(vj,knob,e){
    if(!vj.active)return;
    const touch=[...e.changedTouches].find(t=>t.identifier===vj.id);
    if(!touch)return;
    let dx=touch.clientX-vj.startX, dy=touch.clientY-vj.startY;
    const d=Math.sqrt(dx*dx+dy*dy);
    if(d>VJ_RADIUS){dx*=VJ_RADIUS/d;dy*=VJ_RADIUS/d;}
    vj.dx=dx/VJ_RADIUS; vj.dy=dy/VJ_RADIUS;
    knob.style.transform=`translate(${dx}px,${dy}px)`;
  }
  function onEnd(vj,knob,e){
    const t=[...e.changedTouches].find(t=>t.identifier===vj.id);
    if(!t)return;
    vj.active=false;vj.id=-1;vj.dx=0;vj.dy=0;
    knob.style.transform='translate(0,0)';
  }

  document.addEventListener('touchstart',e=>{
    onStart(LEFT,vjL,lKnob,e);
    onStart(RIGHT,vjR,rKnob,e);
  },{passive:true});
  document.addEventListener('touchmove',e=>{
    onMove(vjL,lKnob,e);
    onMove(vjR,rKnob,e);
  },{passive:true});
  document.addEventListener('touchend',e=>{onEnd(vjL,lKnob,e);onEnd(vjR,rKnob,e);});
  document.addEventListener('touchcancel',e=>{onEnd(vjL,lKnob,e);onEnd(vjR,rKnob,e);});
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAMEPAD (GameSir G8+ / Xbox layout)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const GP={connected:false,index:-1};
const GP_PREV_BTN=new Array(17).fill(false);

function pollGamepad(delta){
  const gamepads=navigator.getGamepads?navigator.getGamepads():[];
  let gp=null;
  for(const g of gamepads){if(g&&g.connected){gp=g;GP.index=g.index;GP.connected=true;break;}}
  if(!gp){GP.connected=false;return;}

  const dead=settings.deadzone;
  const axes=gp.axes;
  const btns=gp.buttons;

  // Left stick â€” move
  const lx=Math.abs(axes[0])>dead?axes[0]:0;
  const ly=Math.abs(axes[1])>dead?axes[1]:0;

  // Right stick â€” look
  const rx=Math.abs(axes[2])>dead?axes[2]:0;
  const ry=Math.abs(axes[3])>dead?axes[3]:0;

  // Sprint (LT = axis 6 or button 6)
  const lt=btns[6]?btns[6].value||0:0;
  const sprint=lt>0.3?settings.sprintMult:1;
  const spd=settings.speed*sprint*delta;

  // Movement
  if(lx||ly){
    const fwd=new THREE.Vector3(-Math.sin(yaw),0,-Math.cos(yaw));
    const right=new THREE.Vector3(-Math.sin(yaw-Math.PI/2),0,-Math.cos(yaw-Math.PI/2));
    camera.position.addScaledVector(fwd,-ly*spd);
    camera.position.addScaledVector(right,lx*spd);
    clampCamera();
  }

  // Look
  if(rx||ry){
    const sens=settings.sensitivity*delta*1.5;
    yaw -= rx*sens;
    pitch -= (settings.invertY?-1:1)*ry*sens;
    pitch=Math.max(-Math.PI/2.2,Math.min(Math.PI/2.2,pitch));
  }

  // Button events (edge detect)
  const pressed=i=>btns[i]&&btns[i].pressed&&!GP_PREV_BTN[i];
  if(pressed(0)){triggerInteract();}        // A
  if(pressed(1)){if(drawMode)wbClose();else if(document.getElementById('playtestOverlay').classList.contains('open'))closePlatyest();else if(document.getElementById('chronicleOverlay').classList.contains('open'))chrClose();else closeModal();}  // B
  if(pressed(3)){if(drawMode)wbClose();else toggleDrawMode();}  // Y
  if(pressed(2)){jumpToWall('north');}       // X
  if(pressed(9)){openSettings();}            // Start
  // D-pad
  if(pressed(12))galleryScroll(-1);          // Up
  if(pressed(13))galleryScroll(1);           // Down

  for(let i=0;i<btns.length;i++)GP_PREV_BTN[i]=btns[i]?btns[i].pressed:false;
}

window.addEventListener('gamepadconnected',e=>{
  GP.connected=true;GP.index=e.gamepad.index;
  toast('Controller connected: '+e.gamepad.id.slice(0,30),'good');
});
window.addEventListener('gamepaddisconnected',()=>{GP.connected=false;toast('Controller disconnected');});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  KEYBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const keys={};
window.addEventListener('keydown',e=>{keys[e.code]=true;});
window.addEventListener('keyup',e=>{keys[e.code]=false;});
window.addEventListener('keydown',e=>{
  if(e.code==='KeyE')triggerInteract();
  if(e.code==='Escape'){
    if(drawMode) wbClose();
    else if(document.getElementById('playtestOverlay').classList.contains('open')) closePlatyest();
    else if(document.getElementById('chronicleOverlay').classList.contains('open')) chrClose();
    else closeModal();
  }
  if(e.code==='KeyF')document.fullscreenElement?document.exitFullscreen():document.documentElement.requestFullscreen();
  if(e.code==='KeyQ')wbOpen('east');
  if(e.code==='KeyR')wbOpen('west');
});

function pollKeyboard(delta){
  const spd=settings.speed*(keys['ShiftLeft']?settings.sprintMult:1)*delta;
  const fwd=new THREE.Vector3(-Math.sin(yaw),0,-Math.cos(yaw));
  const right=new THREE.Vector3(-Math.sin(yaw-Math.PI/2),0,-Math.cos(yaw-Math.PI/2));
  if(keys['KeyW']||keys['ArrowUp'])   {camera.position.addScaledVector(fwd,spd);clampCamera();}
  if(keys['KeyS']||keys['ArrowDown']) {camera.position.addScaledVector(fwd,-spd);clampCamera();}
  if(keys['KeyA']||keys['ArrowLeft']) {camera.position.addScaledVector(right,-spd);clampCamera();}
  if(keys['KeyD']||keys['ArrowRight']){camera.position.addScaledVector(right,spd);clampCamera();}
}

// Mouse look (desktop)
let mouseLook=false;
canvas.addEventListener('mousedown',()=>{mouseLook=true;});
window.addEventListener('mouseup',()=>{mouseLook=false;});
window.addEventListener('mousemove',e=>{
  if(!mouseLook)return;
  const sens=settings.sensitivity*0.003;
  yaw-=e.movementX*sens;
  pitch-=(settings.invertY?-1:1)*e.movementY*sens;
  pitch=Math.max(-Math.PI/2.2,Math.min(Math.PI/2.2,pitch));
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MOVEMENT & CLAMP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function clampCamera(){
  camera.position.x=Math.max(-ROOM_W/2+0.5, Math.min(ROOM_W/2-0.5, camera.position.x));
  camera.position.y=1.7; // locked height
  camera.position.z=Math.max(-ROOM_D/2+0.5, Math.min(ROOM_D/2-0.5, camera.position.z));
}

function applyVJMovement(delta){
  if(!vjL.active&&!vjR.active) return;
  const spd=settings.speed*delta;
  const fwd=new THREE.Vector3(-Math.sin(yaw),0,-Math.cos(yaw));
  const right=new THREE.Vector3(-Math.sin(yaw-Math.PI/2),0,-Math.cos(yaw-Math.PI/2));
  if(vjL.active){
    camera.position.addScaledVector(fwd,-vjL.dy*spd);
    camera.position.addScaledVector(right,vjL.dx*spd);
    clampCamera();
  }
  if(vjR.active){
    const sens=settings.sensitivity*delta*1.8;
    yaw-=vjR.dx*sens;
    pitch-=(settings.invertY?-1:1)*vjR.dy*sens;
    pitch=Math.max(-Math.PI/2.2,Math.min(Math.PI/2.2,pitch));
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PARTICLES (dust motes)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let particleSystem;
function buildParticles(){
  if(settings.perfMode)return;
  const count=120;
  const geo=new THREE.BufferGeometry();
  const pos=new Float32Array(count*3);
  for(let i=0;i<count*3;i+=3){
    pos[i]=(Math.random()-0.5)*ROOM_W*0.9;
    pos[i+1]=Math.random()*ROOM_H;
    pos[i+2]=(Math.random()-0.5)*ROOM_D*0.9;
  }
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  const mat=new THREE.PointsMaterial({color:0xc8a84c,size:0.025,transparent:true,opacity:0.18});
  particleSystem=new THREE.Points(geo,mat);
  scene.add(particleSystem);
}

function animateParticles(t){
  if(!particleSystem)return;
  const pos=particleSystem.geometry.attributes.position.array;
  for(let i=0;i<pos.length;i+=3){
    pos[i+1]+=Math.sin(t*0.3+i)*0.001;
    if(pos[i+1]>ROOM_H)pos[i+1]=0;
  }
  particleSystem.geometry.attributes.position.needsUpdate=true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TORCH FLICKER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function animateTorches(t){
  torchLights.forEach(({light,baseInt,phase})=>{
    light.intensity=baseInt+Math.sin(t*4+phase)*0.2+Math.sin(t*7+phase*2)*0.1;
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TOAST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const toastEl=document.getElementById('toast');
let toastTimer;
function toast(msg,cls=''){
  toastEl.textContent=msg;toastEl.className='show '+(cls||'');
  clearTimeout(toastTimer);toastTimer=setTimeout(()=>toastEl.className='',2400);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RESIZE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.addEventListener('resize',()=>{
  renderer.setSize(window.innerWidth,window.innerHeight);
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let frameCount=0;
function animate(){
  requestAnimationFrame(animate);
  const delta=Math.min(clock.getDelta(),0.05);
  const t=clock.elapsedTime;

  pollGamepad(delta);
  pollKeyboard(delta);
  applyVJMovement(delta);
  doJump(delta);
  applyCamera();

  // Wall nav â€” show when near/facing north (card gallery) wall
  const facingNorth = Math.abs(yaw % (Math.PI*2) - Math.PI) < 1.2 || Math.abs(yaw % (Math.PI*2) + Math.PI) < 1.2;
  const nearNorth = camera.position.z < -ROOM_D/2 + 6;
  const wallNavEl = document.getElementById('wallNav');
  if((facingNorth && nearNorth) || jumpTarget?.ry === 0){
    wallNavEl.classList.add('show');
  } else if(!nearNorth){
    wallNavEl.classList.remove('show');
  }

  // Interaction check every 3 frames
  if(frameCount%3===0) checkInteraction();

  // Room label
  const rl=getRoomLabel();
  if(roomLabelEl.textContent!==rl){roomLabelEl.textContent=rl;roomLabelEl.classList.add('show');}

  animateTorches(t);
  animateParticles(t);
  animateTable(t);

  renderer.render(scene,camera);
  frameCount++;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setLoad(pct,msg){
  document.getElementById('loadBar').style.width=pct+'%';
  document.getElementById('loadMsg').textContent=msg;
}

async function init(){
  setLoad(10,'Building room...');
  buildRoom();
  setLoad(30,'Lighting torches...');
  buildLighting();
  setLoad(45,'Placing table...');
  buildTable();
  setLoad(55,'Loading card gallery...');
  buildGallery(0);
  setLoad(70,'Setting up chronicle panels...');
  buildChroniclePanels();
  setLoad(80,'Adding wall labels...');
  addWallLabels();
  setLoad(88,'Summoning dust motes...');
  buildParticles();
  setLoad(92,'Setting up controls...');
  setupVirtualJoysticks();
  updateJoystickVisibility();
  setLoad(96,'Loading whiteboard drawings...');
  // Wait for fonts before building gallery textures
  await document.fonts.ready;
  wbInitTextures();
  setLoad(100,'Welcome to the Forge Room.');
  await new Promise(r=>setTimeout(r,600));
  document.getElementById('loading').style.display='none';
  animate();
  // Jump to gallery on start
  setTimeout(()=>{
    jumpToWall('north');
    document.getElementById('wallNav').classList.add('show');
    toast('Welcome to the Forge Room âœ¦','good');
  },400);
}

// Listen for data changes from other tabs
window.addEventListener('storage',e=>{
  if(e.key===STORE_FORGE){
    loadForgeData();
    buildGallery(galleryPage);
    buildTableCardSpread();  // refresh deck spread on table
  }
  if(e.key===STORE_CHRONICLE){
    refreshChroniclePanels();
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PWA INSTALL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let deferredInstallPrompt = null;

window.addEventListener('beforeinstallprompt', e=>{
  e.preventDefault();
  deferredInstallPrompt = e;
  document.getElementById('installBanner').classList.add('show');
});

function doInstall(){
  if(!deferredInstallPrompt) return;
  deferredInstallPrompt.prompt();
  deferredInstallPrompt.userChoice.then(r=>{
    document.getElementById('installBanner').classList.remove('show');
    if(r.outcome==='accepted') toast('Forge Room installed!','good');
    deferredInstallPrompt = null;
  });
}

window.addEventListener('appinstalled', ()=>{
  document.getElementById('installBanner').classList.remove('show');
  deferredInstallPrompt = null;
  toast('Forge Room installed!','good');
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ANDROID BACK BUTTON â€” require double-back or confirm
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let backPressCount = 0;
let backPressTimer = null;

// Handle popstate (Android back button fires this)
history.pushState({page:'forge-room'}, '');
window.addEventListener('popstate', e=>{
  // First, check if any overlay is open and close it
  if(drawMode){ wbClose(); history.pushState({page:'forge-room'},''); return; }
  if(document.getElementById('playtestOverlay').classList.contains('open')){
    closePlatyest(); history.pushState({page:'forge-room'},''); return;
  }
  if(document.getElementById('chronicleOverlay').classList.contains('open')){
    chrClose(); history.pushState({page:'forge-room'},''); return;
  }
  if(document.getElementById('modal').classList.contains('open')){
    closeModal(); history.pushState({page:'forge-room'},''); return;
  }
  // Nothing open â€” double-back to exit
  backPressCount++;
  history.pushState({page:'forge-room'},'');
  if(backPressCount === 1){
    toast('Press back again to exit Forge Room');
    backPressTimer = setTimeout(()=>{ backPressCount = 0; }, 2000);
  } else if(backPressCount >= 2){
    clearTimeout(backPressTimer);
    backPressCount = 0;
    // Actually navigate away
    history.back();
    history.back();
  }
});

init();
</script>
</body>
</html>
